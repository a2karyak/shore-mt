# --------------------------------------------------------------- #
# -- Copyright (c) 1994, 1995 Computer Sciences Department,    -- #
# -- University of Wisconsin-Madison, subject to the terms     -- #
# -- and conditions given in the file COPYRIGHT.  All Rights   -- #
# -- Reserved.                                                 -- #
# --------------------------------------------------------------- #

This file contain support for configuring a SHORE source workspace.

After checking out a workspace perform the following steps in
the shore (top level) directory:

tools/makemake .	// to generate the makefiles
tools/depend		// to make .depend files

Makefile files should never be updated.  Instead, edit the
corresponding Imakefile.  To generate the new Makefile, run
	make make
if the Makefile already exists.
If it does not already exist run:
	DOT/tools/makemake DOT
where DOT is the path to the top level directory.

If you make .depend files you can generate new ones with 
	make depend
Otherwise, use (as decribed above)
	DOT/tools/makemake DOT

How it all works (Marvin Solomon, Tue Jan 28 14:42:23 CST 1997).
Eventually, this may turn into a TeX document in the documentation
tree somewhere.
====================== long version (over 500 lines)

tools/makemake:
	Invoked as
			makemake TOP [ CONFIG ]
		where TOP is a relative path to the root directory of the installation
		(generally ".") and CONFIG defaults to TOP/config
		(NB: the "root directory" is the one containing src, tools, and config
		as subdirs).
	The typical invocation
		tools/makemake .
	Searches the subtree for all files named Imakefile and builds a Makefile
		in the same directory.  For example, for the Imakefile
		./src/common/Imakefile, the command is
			imake -I./src/common -I./src/common/.. -I./config \
			-DTop=./../.. \
			-f./src/common/Imakefile \
			-s./src/common/Makefile.new
		(It first checks that there is not a writable Makefile in
		the directory, and afterwards moves Makefile.new to Makefile
		and makes it read-only).
	Once the Makefile is built, "make make" in the directory will invoke
		TOP/tools/makemake TOP
	for example, in src/common, it does
		./../../tools/makemake ./../..
	This results in the imake call
		imake -I. -I./.. -I./../../config -DTop=./../.. \
			-f./Imakefile
			-s./Makefile.new
imake:
	The tools/makemake script assumes imake is in the caller's path.
	Imake is a rather complex C program to do a rather simple task.
	It is distributed as part of the X11 distribution.  It slightly
	preprocesses the Imakefile (although that feature is not used
	by Shore), then calls the C pre-processor cpp, and finally slightly
	post-processes the output, creating Makefile.new.  The C pre-processor
	is called with the -I and -D flags supplied, as well as a couple
	of flags compiled into imake itself when it was built, indicating
	the platform.  In the above example, on an X66 Solaris 2.5.1 platform,
	imake calls cpp as follows (according to imake -v):
		/usr/ccs/lib/cpp -I. -Uunix -Di386 -DSVR4 -DSVR4 \
			-I. -I./.. -I./../../config -DTop=./../.. Imakefile.c 
	where Imakefile.c is the three-line file
		#define IMAKE_TEMPLATE "Imake.tmpl"
		#define INCLUDE_IMAKEFILE <Imakefile>
		#include IMAKE_TEMPLATE
	Imake preprocesses the Imakefile before handing it to cpp, changing
		# foo
	to
		XCOMM foo
	if foo is not one of the cpp directives (if, ifdef, pragma, etc)
	It postprocess the output:
		(1) Change @@ to newline. This is so that we can write cpp macros
		whose expansion is multi-line:
			#define Foo line1 @@\
			line2 @@\
			line3
		The backslashes at the ends of lines cause the definition of
		Foo to be the single line
			line1 @@ line2 @@ line3
		The imake postprocessing changes this to
			line1
			line2
			line3
		(2) Strip trailing whitespace from all lines (after replacing @@)
		(3) Remove ccp output "# line" lines etc
		(4) Change XCOMM to # at that start of a line
		(5) Change space to tab at the start of a line unless 
			the line looks like the start of a rule (e.g. "foo: ")
		(6) Possibly other stuff:  The man page, the comment in the source,
			and the actual code seem somewhat at odds.
	In summary, imake uses cpp to preprocess Imake.tmpl and then cleans
	up the output a bit.  The preprocessing is done with
		an include path of ., .., TOP/config
		the following macros defined
			macros defining the platform (e.g. i386, SVR4, etc)
			INCLUDE_IMAKEFILE  = <Imakefile>
			Top = ./../.. (path back up to the top of the source tree)

I will refer to Imake.tmpl and all files it includes directly or indirectly
(such as Imakefile) as "pre-make" files.
Pre-make files contain the following
	(1) Comments in /* .. */.   These are stripped out by cpp and never
		appear in the generated Makefile.  They are used to explain the pre-make
		files.
	(2) Lines starting with CMNT.  Since the first thing in Imake.tmp is
			#define CMNT #,
		they turn into comment lines (lines starting with '#') in the
		generated Makefile.  They include things like a copyright notice,
		documentation on how the Makefile was generated
			CMNT This Makefile is generated specifically for Platform machines.
		etc.
	(3) #include lines -- more on this below
	(4) #define macro definitions.  They include
		(a) Flags for "conditional compilation", such as
			#if ...
			#define	USE_PURE
			#endif

			#ifdef USE_PURE
			...
		(b) "processor variables" used to generate lines in the Makefile.
			These are supposed to be mixed case, but there are a few
			that are all upper case.  Examples are
				in Platform.select
					#if ...
					#define OpSys SOLARIS2
				then in Project.tmpl
					OPSYS = OpSys
				which generates 
					OPSYS = SOLARIS2
			An all upper-case example is in Project.tmpl
				#define	PURE_STUBS	$(PURIFY_DIR)/pure_stubs.a
				GLOBAL_LDFLAGS += PURE_STUBS
		(c) "subroutines" for generating stylized sequences in the Makefile.
			The X convention is for these to be mixed-case, but the
			convention here seems to be to use all lower-case.
			They are mostly (always?) defined in Imake.rules.
			An example is
				#define statistics(datfile,flags,statfiles) @@\
				depend:: statfiles                          @@\
				clean::                                     @@\
					-@$(RM) -f statfiles                    @@\
				statfiles: datfile $(STATPL)                @@\
					$(PERL) -s $(STATPL) flags datfile
	(5) #ifdef etc.
	(6) Literal pieces of stuff to appear in the Makefile, mostly
		make variable definitions such as (from Imake.rules)	
			#if IS_SPARC_SUNOS41
			PURIFY_SUPPORTED = -DPURIFY
			#define PURIFY_LIB $(PURIFY_DIR)/purify_stubs.a
			GLOBAL_PURE_OPT = -g++ -collector=$(PURIFY_COLLECTOR)
			#else
			...
		and a few specific rules, such as (in Imake.tmpl)
			default: checkmake automatic all

Imake.tmpl
	This is the "top-level" file that includes everything else.  It is
	fairly short.  The imake man page talks about a hierarchy of includes,
	but for Shore, "#include" lines appear ONLY in Imake.tmpl
		#include <shore.def>
		#include <Platform.select>

		#if (defined(IS_I386_SOLARIS2) || ...
		#define	MAKE_SHELL	/bin/ksh
		#endif
		#if defined(MULTI_SERVER) && !defined(USE_OCOMM)
		#define USE_OCOMM
		#endif

		#ifdef MAKE_SHELL
		SHELL=MAKE_SHELL
		#endif

		CMNT
		CMNT This Makefile is generated specifically for Platform machines.
		CMNT

		#include <Project.tmpl>
		#include <local.tmpl> 

		default: checkmake automatic all

		#include <Imake.rules>

	NB: this is where the Imakefile is included
		#include INCLUDE_IMAKEFILE
		.SUFFIXES: $(NEWSUFFIXES) $(SUFFIXES)

		#include <Project.rules> 
		#include <local.rules> 

		ALWAYS:

	Still more briefly,
		#include <shore.def>
		#include <Platform.select>
		#include <Project.tmpl>
		#include <local.tmpl> 
		#include <Imake.rules>
		#include INCLUDE_IMAKEFILE
		#include <Project.rules> 
		#include <local.rules> 
shore.def:
	This is used to select configuration options.  It is explained somewhat
	in the installation document and long comments in the document itself.
	Its purpose is to define or undefine the following flags:
		BITS64            HIER_CB           OCOMM_USE_TCP     USE_OCOMM
		BOOL_COMPAT       INSTALL_PATH      OCOMM_USE_UDP     USE_PURECOV
		CHEAP_RC          IS_SP2            OLD_SM_BLOCK      USE_PURIFY
		FORCE_AIX4        MAKE_SHELL        PARSETS           USE_PVM3
		FORCE_CC          MULTI_SERVER      PIPE_NOTIFY       USE_PVM3
		FORCE_GCC         NOT_PREEMPTIVE    PTREP             USE_QUANTIFY
		FORCE_MULTIUSER   NO_ERROR_SYSTEMS  RMM               USE_RDTREE
		FORCE_PARSETS     OBJECT_CC         SLAVEPROGRAM      USE_VERIFY
		FORCE_SOLARIS     OCOMM_USE_MPI     SSH_VERBOSE
		GCC_PATH          OCOMM_USE_MYRINET USE_COORD
		GNU_MAKE          OCOMM_USE_PVM     USE_HATESEND
	It also sets SM_PAGESIZE to 8192 and
		DEBUGCODE DEBUGGERSYMBOLS OPTIMIZE
	to OFF or ON.
Platform.select:
	Defines Arch, OpSys, Platform, and defines IS_OPSYS_PLATFORM to be 1
	depending on pre-processor flags set by imake.  The cases currently
	supported are
		ifdef					Arch		OpSys
		sun && sparc 			Sparc		SOLARIS2 or SUNOS41 (see below)
		hpux && hp9000s800		Snake		HPUX8
		mips && ultrix			Mips		Ultrix42
		sgi						Mips		Irix
		__OSF1__ && __PARAGON	I860		OSF1AD
		i386 && linux			I386		Linux
		i386 && FORCE_SOLARIS	I386		SOLARIS2
		aix						Rs6000		AIX41 or AIX32 (see below)
		aix && !FORCE_AIX4		Rs6000		AIX32
	In all cases, Platform is set to the concatenation of Arch and OpSys
	(with a space between) and IS_OPSYS_PLATFORM is set to 1, where
	OPSYS and PLATFORM are upper-case versions of the values of OpSys and
	Platform, respectively.  In the first four cases (through sgi),
	the pre-processor symbols that trigger the case (e.g. sun and sparc)
	as undefined (with #undef) after being tested.

	In the sun sparc case, OpSys is SOLARIS if __svr4__ or FORCE_SOLARIS
	is defined.  (This appears to be a bug, since __svr4__ is never defined
	the way imake is called.  The confusion is probably due to the fact
	that this symbol is normally defined by gcc (and probably cc) when it
	calls cpp.)

	In the aix case OpSys is AIX41 if FORCE_AIX is defined and AIX32 otherwise.
Project.tmpl
	This is a HUGE file.  Its main purpose seems to be to generate a bunch
	of make variable definitions (XXX = YYY) in the generated Makefile.
	It starts with about 140 lines of local configuration stuff giving
	pathnames for various utilities.  Many of the definitions are conditional
	on whether SUP_DIRS is defined.  SUP_PATH is not defined anywhere (it's
	there for compatibility with the old /usr/psup config our deparment
	got rid of a couple of years ago).  When it is *NOT* defined, this
	section boils down to
		#ifdef INSTALL_PATH
		INSTALL_DIR = INSTALL_PATH
		#else
		INSTALL_DIR = $(TOP)/installed
		#endif
		TCL_DIR = /s/tcl
		BISON_DIR = /s/std/bin
		FLEX = /s/flex/bin/flex
		FLEXLIB = /s/flex/lib/libfl.a
		GDBM_DIR = /s/gdbm
		#endif
	followed by a big chunk of stuff involving purify, which boils down
	(in the sparc solaris case, when USE_PURIFY, USE_QUANTIFY, and
	USE_PURECOV are defined) to
		PURE_GOPT=\
			-inuse-at-exit -ignore-signals=0x40000000 -first-only \
			-leaks-at-exit \
			-pointer-mask=0xfffffffe -copy-fd-output-to-logfile=1,2
		PURE_COLLECTOR =/usr/ccs/bin/ld 
		PURIFY_DIR = /s/purify/bin
		PURIFY_COLLECTOR= $(PURE_COLLECTOR)
		PURE_3_OPT=$(PURE_GOPT) -threads -thread-stack-change=0x3000 \
			-max_threads=64
		PURE_OPT = $(PURE_3_OPT)
		QUANT_COMPILE_OPTS = -g
		QUANT_DIR = /s/quantify/bin
		QUANTIFY_COLLECTOR =$(PURE_COLLECTOR)
		QUANT_OPT = 
		PURECOV_DIR = /s/purecov/bin
		PURECOV_COLLECTOR =$(PURE_COLLECTOR)
		PURECOV_OPT = 
	and then
		CTAGS_DIR = /s/emacs/bin
	After the line
		/**************** End of commonly set options ********************/
	comes some general stuff
		TOP = Top
		CMNT make sure it's not rm -f, since
		CMNT the makefiles specify -f
		RM = rm
		PLATFORM = Platform
		ARCH = Arch
		OPSYS = OpSys
	Next a huge number of other defs, keyed on platform and option
	selection.  For brevity, I'll only show the case for x86, solaris, gcc,
	and not any of USE_VERIFY, USE_PVM3, USE_OCOMM, USE_MYRNET, USE_MPI:
		FC_DIR = $(TOP)/src/fc
		FC_INCL = -I$(FC_DIR)
		FC_LIB = $(FC_DIR)/libfc.a
		COMMON_DIR = $(TOP)/src/common
		COMMON_INCL = -I$(COMMON_DIR)
		COMMON_LIB = $(COMMON_DIR)/libcommon.a
		SM_DIR = $(TOP)/src/sm
		SM_INCL = -I$(SM_DIR)
		SM_LIB = $(SM_DIR)/libsm.a
		STHREAD_DIR = $(TOP)/src/sthread
		STHREAD_INCL = -I$(STHREAD_DIR)
		STHREAD_LIB = $(STHREAD_DIR)/libst.a
		RPC_DIR =  $(TOP)/src/rpc4.0
		RPC_LIB =  -lnsl
		RPC_INCL =  
		RPC_SVC_LIB = -lnsl
		RPCGEN = $(RPC_DIR)/rpcgen/rpcgen
		VAS_DIR =  $(TOP)/src/vas
		VAS_INCL = -I. -I$(VAS_DIR)/include -I$(VAS_DIR)/common
		VAS_APP_LIB = $(VAS_DIR)/client/libvas.a $(VAS_DIR)/common/libcommon.a
		OC_DIR =  $(TOP)/src/lil/oc
		OC_INCL = -I$(OC_DIR) 
		OC_LIB = $(OC_DIR)/liboc.a
		SDL_DIR =  $(TOP)/src/sdl
		SDL_INCL = -I$(SDL_DIR)/include
		SDL_LIB = $(SDL_DIR)/libsdl.a
		GDBM_INCL = -I$(GDBM_DIR)/include
		GDBM_LIB = $(GDBM_DIR)/lib/libgdbm.a
		VERIFY_DIR = 
		VERIFY_INCL = 
		VERIFY_LIB = 
		GDBM_LIB = 
	Then a section on compilation options (again, I'll only show the solaris
	case; GLOBAL_LDFLAGS = -lm -lnsl -lsocket -lposix4 is the only thing
	that's really ideosyncratic):
		#define GCCFLAGS   -fno-implicit-templates
		#if DEBUGCODE == ON
		DEBUGFLAGS = -DDEBUG
		#else
		DEBUGFLAGS = -DNDEBUG
		#endif
		#if DEBUGGERSYMBOLS == OFF
		CCDEBUGSYMBOLS = 
		CFRONTDEBUGSYMBOLS = 
		GCCDEBUGSYMBOLS = 
		#endif
		#if OPTIMIZE==OFF
		CCOPTIMIZE = 
		CFRONTOPTIMIZE = 
		GCCOPTIMIZE = -O
		#else
		CCOPTIMIZE =  -O
		CFRONTOPTIMIZE =  -O 
		GCCOPTIMIZE =  -finline-functions -fexpensive-optimizations -O2
		#endif /* OPTIMIZE */
		#if DEBUGGERSYMBOLS == ON
		CCDEBUGSYMBOLS =  -g
		CFRONTDEBUGSYMBOLS = -g 
		GCCDEBUGSYMBOLS = -g3 -fno-inline
		#endif
		#ifdef GCC_PATH
		GCC = GCC_PATH
		#else
		GCC = gcc
		#endif
		GCCDEBUGSYMBOLS += $(QUANT_COMPILE_OPTS)
		CPLUSPLUS = $(GCC) -x c++
		CPLUSDEBUGSYMBOLS = $(GCCDEBUGSYMBOLS)
		CPLUSLIB =  -liberty -lg++ -lstdc++ 
		CPLUSOPTIMIZE = $(GCCOPTIMIZE)
		CCFLAGS = GCCFLAGS
		CC = $(GCC) -x c 
		CMNT	gcc w/o -x option knows that .o is object file
		CPP = $(GCC) -E -P -ansi  -x c-header -U__cplusplus
		LD = $(GCC)
		PTREPOSITORY = 
		TEMPLATEDEF =
		GLOBAL_LDFLAGS = -lm -lnsl -lsocket -lposix4
		GLOBAL_LDFLAGS += -lstdc++ 
	Then a section on various tools.  Assuming USE_PURIFY
		#define	PURE_STUBS	$(PURIFY_DIR)/pure_stubs.a
		GLOBAL_LDFLAGS += PURE_STUBS
		AUXFLAGS =
		PROTOIZE = protoize
		AR = /usr/ccs/bin/ar
		ARFLAGS = rv
		MKDEPEND = $(PERL) -s $(TOP)/tools/w4
		MKDEPFLAGS = '$(GCC) -x c++ -E'
		PERL = perl
		RANLIB = ranlib
		CO = cvs update
		ERRORPL =$(TOP)/tools/errors.pl
		STATPL = $(TOP)/tools/stats.pl
		CTAGS = $(CTAGS_DIR)/ctags -d --typedefs-and-c++  --c++
		RANLIB_IFNEEDED = echo skipping ranlib
		GREP = egrep
		PROTOIZE_IFNEEDED = $(PROTOIZE)
		SYMLINKS =
		PROFILE= 
		INCLUDE = -I. -I$(TOP)/config
		INCLUDE += -I$(PURIFY_DIR) 
		INCLUDE += -I$(QUANT_DIR) 
		INCLUDE += -I$(PURECOV_DIR)
		CPPFLAGS=
		PLATFORM_FLAGS= -D$(ARCH) -D$(OPSYS)
	and finally, all the remaining C flags.
		CFLAGS = $(CCFLAGS) $(INCLUDE) $(AUXINCL) $(DEBUGFLAGS) \
			$(PLATFORM_FLAGS) \
			$(PROFILE) $(AUXFLAGS) $(PURIFY_SUPPORTED) $(LOCAL_CFLAGS)
		CPLUSFLAGS = $(CFLAGS) $(TEMPLATEDEF) $(CPLUSOPTIMIZE)
		COMPILE_NOSYMBOL.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(CCOPTIMIZE) -c
		COMPILE.c = $(COMPILE_NOSYMBOL.c) $(CCDEBUGSYMBOLS) 
		COMPILE_NOSYMBOL.C = $(CPLUSPLUS) $(CPLUSFLAGS) $(CPPFLAGS) -c
		COMPILE.C = $(COMPILE_NOSYMBOL.C) $(CPLUSDEBUGSYMBOLS) 
		COMPILE_NOSYMBOL.cc = $(CPLUSPLUS) $(CPLUSFLAGS) $(CPPFLAGS) -c
		COMPILE.cc = $(COMPILE_NOSYMBOL.cc) $(CPLUSDEBUGSYMBOLS) 
		EXECS =
		ALLTARGETS =
		SUBDIR=
		NEWSUFFIXES =
		SUBDIRCOMMANDS = \
			tags clean clean_symlinks symlinks \
			add depend install clean_install all
		TAGFILES = $(SRCS) $(HFILES)
local.tmpl 
	This generates nothing but a long comment in the Makefile explining
	how to override things by putting a local.tmpl file in specific
	directories.  Because of the -I flags given to imake, a local.tmpl
	in an individual directory or its parent will override this local.tmpl.
Imake.rules
	Lots of general make rules.  It apparently assumes certain make macros
	are defined according to the comment
		SRC for sources
		OBJ for objects
		DISPOSABLE for non precious files
		LDLIBS for libraries
	then
		NEWSUFFIXES += .C
		NEWSUFFIXES += .htag .itag .Ctag .ctag                           
	then long funky rules for
		.c.o
		.C.o
		.cc.o
	then a buch of "subroutines" having the general outline
		#ifndef somefunc
		#define somefunc(args) ...
		#endif
	as an example,
		#define c_program(program, objlist, libs)		@@\
		clean::											@@\
			-@$(RM) -f program objlist					@@\
														@@\
		program: objlist libs 							@@\
			$(MAKE) program.link						@@\
		program.link:									@@\
			$(LD) -o program objlist libs extra_ld_flags \
				$(LDFLAGS) $(LOCAL_LDFLAGS) $(CLIB) \
				$(GLOBAL_LDFLAGS)						@@\
			pxdb_message
	(The macros extra_ld_flags and pxdb_message are null except on HP).
	The Imakefile could contain a call
		c_program(myprog, main.o sub.o, mylib.a)
	which would expand to the following (the LD would be one line; it is
	split here for clarity)
		clean::
			-@$(RM) -f myprog main.o sub.o
		myprog: main.o sub.o
			$(MAKE) myprog.link
		myprog.link:
			$(LD) -o myprog main.o sub.o mylib.a
				$(LDFLAGS) $(LOCAL_LDFLAGS) $(CLIB) $(GLOBAL_LDFLAGS)
	The subroutines defined are
		c_program(program, objlist, libs)
		c_plus_program(program, objlist, libs)
		poe_c_plus_program(program, objlist, libs)
		purify_c_plus_program(program, objlist, libs, pure_options)
		quantify_c_plus_program(program, objlist, libs, quant_options)
		purecov_c_plus_program(program, objlist, libs, pure_options)
		pureboth_c_plus_program(program, objlist, libs, pure_options)
		build_library(lib, objlist)
		append_library(lib, objlist)
		build_joint_library(lib, objlist, otherlibs)
		depend_target(src_list)
		clean_files(files)
		symbolic_links(lnks)
		error_codes(datfile,flags,errfiles)
		statistics(datfile,flags,statfiles)
		install_copy(dir, toinstall)
		install_move(dir, toinstall)
		do_subdirs(commands, subdirs)
		do_tags(srcs)
#include INCLUDE_IMAKEFILE
	Note that the Imakefile is included after everthing except Project.rules
	and local.rules.
Project.rules 
	A bunch of canned rules, which thus appear at the tail of each
	generated Makefile
		default: all
		all::	automatic $(ALLTARGETS) $(EXEC)
		do_subdirs($(SUBDIRCOMMANDS),$(SUBDIR))
		do_tags($(TAGFILES))
		tests:: ALWAYS
			if(test -d tests) then \
				(cd tests; $(MAKE) $(OPTIONS);)\
			fi; 
		do_subdirs(tests,$(SUBDIR))
		make:
			$(TOP)/tools/makemake $(TOP)
		clean::
			@echo cleaning `pwd`
		install::
		clean_install::
		depend:: automatic
			@touch .depend
	A trick to tell if we're using the same make as the
	one for which we configured the makefiles
	(should get rid of that crap!)
		MCK = /tmp/m.ck$$$$
		#ifdef GNU_MAKE
		PWD = $(shell pwd)
		GTEST = -eq 0
		GMSG = "Makefiles were configured for GNU make; you must ..."
		#else
		PWD:sh = pwd
		sh:: automatic
		GTEST = -gt 0
		GMSG = "Makefiles were not configured for GNU make; you may not ..."
		#endif
		nothing:;
		automatic:: checkmake
		checkmake::
			@($(MAKE) -v nothing 1>$(MCK) 2>&1 || echo "nope" 1>$(MCK););\
			set +e; j=eval grep -s "GNU" $(MCK);\
			if(test `grep -c "GNU" $(MCK)` $(GTEST)) then \
				echo $(GMSG); exit 1;\
			fi; /bin/rm -f $(MCK)
	Symlinks - each Imakefile can override the default (empty) $(SYMLINKS).
		automatic:: symlinks
		symlinks::  
		clean_symlinks:: 
		symbolic_links($(SYMLINKS))

		include .depend
	CVS add
		add:: 
			-for i in `echo $(SRC.cvs)`; \
				do cvs add `basename $$i.junk .junk`; done;
local.rules 
	Like local.tmpl, this expands to a long comment, but can be overridden
	by local.tmpl files in specific directories.  The only place where
	this acually happens is in src/examples/local.rules
====================== shorter version (151 lines)
tools/makemake
	Normally called from the TOP directory (the one that contains
	tools, config, and src as subdirs) as "tools/makemake .".
	It searches for all files named Imakefile and for each one, uses imake to
	create a Makefile in same directory by calling imake.  For example,
	given  ./src/common/Imakefile, the call is
		imake -I./src/common -I./src/common/.. -I./config \
			-DTop=./../.. \
			-f./src/common/Imakefile \
			-s./src/common/Makefile.new
	Once created, the Makefile has a "make make" command which does
	the same thing, but assuming you're in the same directory as the Imakefile:
		imake -I. -I./.. -I./../../config -DTop=./../.. \
			-f./Imakefile
			-s./Makefile.new
imake does essentially just this:
		echo "#include <Imake.tmpl>" \
			| cpp -I. canned-defines imake-args \
				-DINCLUDE_IMAKEFILE="<Imakefile>" \
			| cleanup
	where canned-defines indicate the architecture, imake-args are the
	-I and -D flags passed to imake, and cleanup does a little post-processing.
	In the above example, the cpp call is
		/usr/ccs/lib/cpp -I. -Uunix -Dsparc -DSVR4 -DSVR4 \
			-I. -I./.. -I./../../config -DTop=./../.. \
			-DINCLUDE_IMAKEFILE="<Imakefile>"
	The cleanup postprocessor does a little compensation for deficiencies
	in cpp (and bugs in some implementations of it).  The only non-trivial
	changes are to strip all the generated "# line" lines (rather like
	cpp -P) and to replace every "@@" by a newline, allowing you to
	write macros that (effectively) generate multi-line outputs.
	(This is not possible with cpp by itself).
The Imake.tmp found by the include will be the version in the config directory.
	It is mostly just a bunch of #includes:
		#include <shore.def>
		#include <Platform.select>
		#include <Project.tmpl>
		#include <local.tmpl> 
		#include <Imake.rules>
		#include INCLUDE_IMAKEFILE
		#include <Project.rules> 
		#include <local.rules> 
	By convention all of these files will be found in the config directory
		except for local.tmpl and local.rules (the versions of these
		in the config directory are essentially empty).
The roles of these files are
	shore.def:
		Defines a zillion options (mostly just def/undef, but a few
		with values).  For example FORCE_GCC, FORCE_SOLARIS, USE_PVM3,
		DEBUGCODE=ON, OPTIMIZE=OFF.  These are all cpp "variables" that
		control conditional generation of the Makefile.
	Platform.select
		Defines the cpp symbols Arch, and OpSys depending on the
		-D flags passed to cpp by imake.  In the above example
		(-Dsparc -DSVR4), the values are Arch=Sparc, OpSys=SOLARIS
		(Actually, there's a bug, so this only works if FORCE_SOLARIS
		is defined in shore.def).  Also defines Platform="Sparc SOLARIS"
		and defines IS_SPARC_SOLARIS (to be 1).
	Project.tmpl
		A HUGE file.  Mostly generates
			VAR = VALUE
		or
			VAR += VALUE
		make-variable declarations, based on options selected in
		shore.def and Platform.select.
		Typical examples (there's actually a lot more)
			INSTALL_DIR = $(TOP)/installed
			TCL_DIR = /s/tcl
			BISON_DIR = /s/std/bin
			FLEX = /s/flex/bin/flex
			FLEXLIB = /s/flex/lib/libfl.a
			GDBM_DIR = /s/gdbm
			PURE_GOPT=\
				-inuse-at-exit -ignore-signals=0x40000000 -first-only \
				-leaks-at-exit \
				-pointer-mask=0xfffffffe -copy-fd-output-to-logfile=1,2
			PURE_COLLECTOR =/usr/ccs/bin/ld 
			PURIFY_DIR = /s/purify/bin
			PURIFY_COLLECTOR= $(PURE_COLLECTOR)
			PURE_3_OPT=$(PURE_GOPT) -threads -thread-stack-change=0x3000 \
				-max_threads=64
			PURE_OPT = $(PURE_3_OPT)
			TOP = ./../..
		(or whatever is passed in -DTop=)
			OC_DIR =  $(TOP)/src/lil/oc
			OC_INCL = -I$(OC_DIR) 
			OC_LIB = $(OC_DIR)/liboc.a
			SDL_DIR =  $(TOP)/src/sdl
			SDL_INCL = -I$(SDL_DIR)/include
			SDL_LIB = $(SDL_DIR)/libsdl.a
		conditional on DEBUGGERSYMBOLS == ON:
			CCDEBUGSYMBOLS =  -g
			CFRONTDEBUGSYMBOLS = -g 
			GCCDEBUGSYMBOLS = -g3 -fno-inline

			CPLUSPLUS = $(GCC) -x c++
			CPLUSDEBUGSYMBOLS = $(GCCDEBUGSYMBOLS)
			CPLUSLIB =  -liberty -lg++ -lstdc++ 
			CPLUSOPTIMIZE = $(GCCOPTIMIZE)
			CCFLAGS = GCCFLAGS
			CC = $(GCC) -x c 
			CPP = $(GCC) -E -P -ansi  -x c-header -U__cplusplus
			LD = $(GCC)
			GLOBAL_LDFLAGS = -lm -lnsl -lsocket -lposix4
			GLOBAL_LDFLAGS += -lstdc++ 

			INCLUDE = -I. -I$(TOP)/config
			INCLUDE += -I$(PURIFY_DIR) 
			INCLUDE += -I$(QUANT_DIR) 
			INCLUDE += -I$(PURECOV_DIR)

			COMPILE_NOSYMBOL.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(CCOPTIMIZE) -c
			COMPILE.c = $(COMPILE_NOSYMBOL.c) $(CCDEBUGSYMBOLS) 
			NEWSUFFIXES =
			SUBDIRCOMMANDS = \
				tags clean clean_symlinks symlinks \
				add depend install clean_install all
	local.tmpl
		Can appear in various directories.  When it does, it tends to
		include some rules to override the ones in Project.tmpl
	Imake.rules
		Various "subroutines" for generating canned chunks of Makefile.
		Examples are
			c_program(program, objlist, libs)
			c_plus_program(program, objlist, libs)
			poe_c_plus_program(program, objlist, libs)
			purify_c_plus_program(program, objlist, libs, pure_options)
			quantify_c_plus_program(program, objlist, libs, quant_options)
	Project.rules
		Things that go at the end of all generated makefiles:
			default: all
			all::	automatic $(ALLTARGETS) $(EXEC)
			do_subdirs($(SUBDIRCOMMANDS),$(SUBDIR))
			do_tags($(TAGFILES))
			tests:: ALWAYS
				if(test -d tests) then \
					(cd tests; $(MAKE) $(OPTIONS);)\
				fi; 
			do_subdirs(tests,$(SUBDIR))
			make:
				$(TOP)/tools/makemake $(TOP)
			clean::
				@echo cleaning `pwd`
			install::
			clean_install::
			depend:: automatic
				@touch .depend
		as well as some garbage about testing that the version of Make is
			correct
	local.rules
		local customization (not used except in src/examples).
==========================
tools/depend
	options are -t (set touchonly) and -n (set norm -- stands for "no rm")
	phase 1
		for each f in `find . -name "Makefile" -type f -print`
			rm -f $f:h/.depend (unless -n)
			touch $f:h/.depend
	phase 2
		if Makefile exists, just do "make depend"
		else
			for each subdirectory d that contains d/Makefile
				(cd d; make depend)
	How does make depend work?
		In Imake.rules
			#define depend_target(src_list)             @@\
			depend:: 	automatic                       @@\
			depend:: ALWAYS                             @@\
				-@$(RM) -f .depend                      @@\
				@$(MKDEPEND) $(MKDEPFLAGS) $(CFLAGS) src_list > .depend
		Most Imakefiles have something like
			depend_target($(SRC))
		Also in Imake.rules, the rule for error_codes() generates
			depend:: errfiles
		and the rule for statistics() generates
			depend:: statfiles
		Finally, Project.rules generates
			depend:: automatic
				@touch .depend
			include .depend
		In Project.tmpl, MKDEPEND is defined to be
			$(PERL) -s $(TOP/tools/w4
		and MKDEPFLAGS is (assuming gcc)
			 '$(GCC) -x c++ -E'
============================
Top level:

'make' or 'make all':
	From Project.rules:
		default: all
		all::	automatic $(ALLTARGETS) $(EXEC)
		automatic:: symlinks
		depend:: automatic
	From Project.tmpl
		EXECS =
		ALLTARGETS =
	(NB:  the former line appears to be a typo).  These Make macros are
	(re)defined in various Imakefiles.
	Thus the default 'make" makes symlinks, any local dependencies for
	automatic, and then all the targets specified in ALLTARGETS and EXEC
make symlinks:
	In Imake.rules
		%DEF symbolic_links(lnks)
		%GEN _clean_symbolic_links(lnks)
		symlinks::
			-@for i in `echo lnks`; do %
				if (test ! -h `basename $$i`) then %
					echo $$i;%
					ln -s $$i;%
				fi;%
			done;
		%ENDDEF
		%DEF _clean_symbolic_links(lnks)
		clean:: clean_symlinks
		clean_symlinks::
			-@for i in `echo lnks`;%
				do %
				if (test -h `basename $$i`) then %
					$(RM) -f `basename $$i`; %
				fi;%
				done; 
		%ENDDEF
		%DEF clean_symbolic_links(lnks)
		/* dummy */
		%ENDDEF
	The only one of these to be called directly anywhere is symbolic_links,
	called at the very end of Project.rules
		%GEN symbolic_links($(SYMLINKS))
	SYMLINKS is set to null in Project.tmpl (and in several Imakefiles)
	In a few Imakefiles, it is set to something like this:
		src/sm/ssh/Imakefile:SYMLINKS = ../../sthread/diskrw
	(in some cases, there is more than one element of the list).
========================
proposed policies on targets:

survey of targets in a typical generated Makefile under existing scheme
(either sm or fc directory)
	ALWAYS
		null (PHONY) target
	add
		'cvs add x' for each x in $(SRC.cvs)
	all
		automatic $(ALLTARGETS) $(EXEC)
			-- ALLTARGETS and EXEC are set in Imakefiles
	automatic
		checkmake       -- obsolete
		symlinks 		-- from Project.rules
		$(AUTOMATIC)	-- individual Imakefile
	checkmake
	nothing
		obsolete junk to test which flavor of "make" is in use
	clean
		@echo cleaning `pwd`   -- Project.rules
		calls clean_symlinks   -- Imake.rules, generated by _clean_sym..
		calls -@$(RM) -f program objlist
							-- generated by c_program(program,objlist,libs)
							-- similarly for c_plus_program,
							-- pos_c_plus_program, build_library, 
							-- error_codes, etc.
							-- clean_files(list) also generates 'rm list'
							-- also 'rm tags' directly from Imake.rules
	clean_install
		Should probably be named "uninstall" according to the GNU standards.
		Seems to undo an 'install'
		Generated in Imake.rules from install_copy(dir,list) and install_move:
			for i in list; do rm $(INSTALL_DIR)/dir/i; done
	clean_symlinks
		generated by _clean_symbolic_links(list) (which is called by
			symbolic_links(list) in Imake.rules
		removes all members of list that are symlinks (test -h).
	default
		default: all   -- in Project.tmpl
	depend
		-- in Project.rules
			depend:: automatic
				@touch .depend
		-- in Imake.rules, generated by depend_target(list)
			depend:: automatic
			depend:: ALWAYS
				rm .depend; $(MKDEPEND) ...  list > .depend
			(in other words, first do "automatic", then rebuild .depend
			unconditionally)
			Most Imakefiles seem to call depend_target($(SRC)),
				depend_target($SRC) $(HFILES)), or some such.
		-- also in Imake.rules
			depend::errfiles   --  generated by error_codes()
			depend::statfiles  -- generated by statistics()
	install
		generated by install_copy(dir,list) and install_move(dir,list)
			essentially:
				cp list $(INSTALL_DIR)/dir
	make
		in Project.rules
			make:
				$(TOP)/tools/makemake $(TOP)
	symlinks
		generated by symbolic_links(list), essentially
			for i in list; do; if test ! -h $i then ln -s $$i; fi; done;
	tags
	tests
		in Project.rules
			tests:: ALWAYS
				if (test -d tests) then (cd tests; $(MAKE) $(OPTIONS);) fi
How recursion works:
	in Imake.rules, do_subdirs(cmds, dirs) essentially does
		cmds::
			for i in dirs; do cd $i; $(MAKE); done
	Project.rules calls
		do_subdirs($(SUBDIRCOMMANDS),$(SUBDIR))
		do_subdirs(tests,$(SUBDIR))
	A few Imakefiles also have calls, e.g. in sm/Imakefile
		do_subdirs($(COMMANDS_MINUS_ALL), $(SUBDIR_LOCAL))

	Thus sm/Makefile has
		$(COMMANDS_MINUS_ALL)::
			for i in $(SUBDIR_LOCAL); do cd $$i; $(MAKE); done
		$(SUBDIRCOMMANDS)::
			for i in $(SUBDIR); do cd $$i; $(MAKE); done
		tests::
			for i in $(SUBDIR); do cd $$i; $(MAKE); done
	In Project.tmpl,
		SUBDIRCOMMANDS = \
			tags clean clean_symlinks symlinks \
			add depend install clean_install all
		(in sm/Imakefile, this value is effectively transferred to
		COMMANDS_MINUS_ALL and SUBDIRCOMMANDS is set to null).
	In sm/Imakefile, SUBDIR and SUBDIR_LOCAL are both defined to be
		ssh
	The top-level src/Imakefile does something similar to end up with
		$(COMMANDS_MINUS_ALL)::
			for i in $(SUBDIR_CODE) $(SUBDIR_APP); do cd $$i; $(MAKE); done
		depend install clean_install all tags::
			for i in $(SUBDIR_CODE); do cd $$i; $(MAKE); done
	where
		COMMANDS_MINUS_ALL = tags clean clean_symlinks symlinks add
		SUBDIR_CODE = fc sthread common sm rpc4.0 vas lil util sdl
		SUBDIR_APP = examples oo7 rooms
	Thus we have (e.g)
		all::   automatic $(ALLTARGETS) $(EXEC)
		all::
			 for i in fc sthread common sm rpc4.0 vas lil util sdl; \
			 do cd $$i; $(MAKE); done
	This gives a Fibonacci (exponential) effect.
		Each directory has something like
			all:: automatic
			automatic:: symlinks
			symlinks::
				do local symlinks
			symlinks::
				for each subdir do 'make symlinks'
			all::
				for each subdir to 'make all'
			all::
				do local stuff
		The effect is like this (f == all, g == symlinks, assume two
			subdirs named "l" and "r):
			f(t) {
				g(t);
				F(t);
				f(t.l);
				f(t.r);
			}
			g(t) {
				G(t);
				g(t.l);
				g(t.r);
			}
		Which generates the sequence of calls from f(t):
			g(t) -- calls G(x) for t and all its descendents
			F(t)
			f(t.l)
				g(t.l) -- re-runs G(x) on t.l and decendents
				F(t.l)
				etc
			f(t.r)
				g(t.r) -- re-runs G(x) on t.r and decendents
				F(t.r)
				etc
	The simplest solution is to create "local" and "recursive" versions.
		let all, clean, and install be recusive, and add new targets
		all_local, etc.
			all_local:: automatic
			all_local::
				local actions
			all:: all_local
				for each subdir make all
			automatic:: symlinks_local
			symlinks_local::
				local actions
			symlinks:: symlinks_local
				for each subdir make symlinks
New scheme:
	Top-level  Imake.tmpl simply includes other files (and some comments)
		#include <config.h>
		#include <Platform.select> // defines preproc variables Arch, Opsys,
			and Platform and Make variable IS_XXX_YYY
		#include <Imake.vars>  // defs of Make variables
		#include <local.tmpl> 
		#include <Imake.rules>   // only %DEF
		#include <Imakefile>
		#include <Imake.targets> // standard targets for makefile
[NB rename
	Project.tmpl -> Imake.vars
	Project.rules -> Imake.targets
]

TODO:
	fix the COMM stuff.  It's all over the place (in shore.defs, 

Notes on standard targets in gnu make (make -f /dev/null -p):
	LINK.c =  $(CC)  $(CFLAGS)   $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
	LINK.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
	LINK.o =  $(CC)                          $(LDFLAGS) $(TARGET_ARCH)
	COMPILE.c =  $(CC)  $(CFLAGS)   $(CPPFLAGS) $(TARGET_ARCH) -c
	COMPILE.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
	%: %.cc
		$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@
	%: %.c
		$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@
	%: %.o
		$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@
	%.o: %.cc
		$(COMPILE.cc) $< $(OUTPUT_OPTION)
	%.o: %.c
		$(COMPILE.c) $< $(OUTPUT_OPTION)
Scheme for gathering flags together (on compile or link)
	Define individual cpp vars for each possible piece, e.g.
		in Imake.vars
			#ifdef Optimize
			#define CompilerOptimizeFlags -finline-functions -O2
			#else
			#define CompilerOptimizeFlags -O
			#endif /* Optimize */
		Then in Imake.targets (rename it Imake.post?)
			CXXFLAGS = CompilerOptimizeFlags ...
Problem with putting everything in one file (shore.defs, now config.h):
	#define Foo might be there just to control building of makefiles,
	but waht if Foo appears in some C source?

	Solutions:
		1. Use different files.  E.g., Imake.config used in build,
		and then it generates config.h.
		2. Protect those #defines with #ifdef Imake (or some such)
		3. #undef them at the appropriate time.
		4. Just be careful.
Kinds of config info
	1. compile options (debug or not etc.)  Also -DDEBUG
	2. package selection (PURIFY, CHEAP_RC -- which chooses a version
		of the source file)
	3. locations of commands, libraries, and includes
	4. features, such as MULTI, OCOMM
	5. parameters (BITS64, SM_PAGESIZE)
