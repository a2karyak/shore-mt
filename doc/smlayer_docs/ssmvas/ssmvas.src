\documentstyle[html,titlepage,shore]{article}
\pagestyle{plain}
\makeindex
\sloppy  

\title{Writing Value-Added Servers with the Shore Storage Manager\thanks{This research is sponsored
by the Advanced Research Project Agency, ARPA order number 018 (formerly
8230), monitored by the U.S. Army Research Laboratory under contract
DAAB07-92-C-Q508.
}}
\author{The Shore Project Group \\
Computer Sciences Department \\
UW-Madison \\
Madison, WI \\
\shoreversion \\
\shorecopyright
}
\date{\today}

\begin{document}
\label{ssmvas:TOP}
\maketitle
\tableofcontents
\pagebreak
\externallabels{}{../../labels.pl}
\externallabels{../ssmvas}{labels.pl}

\SHsection{ssmvas:intro}{Introduction}

This tutorial explains, through the use of an example client-server
system, how to write a value-added server (VAS) and client programs
using the Shore Storage Manager (SSM) programming interface.


\SHsubsection{ssmvas:goals}{Goals}

\SHsubsubsection{ssmvas:whatitis}{What this Tutorial Is}

This tutorial illustrates many aspects of writing a VAS, including
\begin{itemize}
\item Using the storage facilities
\item Managing transactions and recovery
\item Using the multi-threading and synchronization facilities
\item Writing a server to support multiple clients using Sun RPC
\item Configuring the SSM using the options package
\item Handling errors
\item Compiling and running programs
\end{itemize}

\SHsubsubsection{ssmvas:whatitisnt}{What this Tutorial Is Not}
\begin{itemize}
\item A general introduction to the SSM, its goals, structure or status.

This type of information is in
\htmldoclink{{\em An Overview of Shore}}{overview.html}
and 
\htmldoclink{{\em The Shore Storage Manager Programming Interface}}{ssmapi.html}.
See
\htmldoclink{{\em The Shore Release}}{release.html}
for an index to the rest of the documentation.

\item A demonstration of all the features of the SSM

\item A general guide to using Sun RPC.

It is assumed
the reader is already familiar with RPC programming.  If not we
recommend the book {\em Power Programming with RPC}, by
John Bloomer, published by O'Reilly \& Associates, Inc.

\item A tutorial on multi-threaded programming in general.
\end{itemize}


\SHsubsection{ssmvas:theexample}{The Example System}

The example used throughout this tutorial is a client-server system,
called {\em grid},
that illustrates many aspects of building a value-added server and
a corresponding client.

\SHsubsubsection{ssmvas:grid}{What the Grid VAS and Grid Client Do}

The grid example is a simple client-server database system for {\em
items} located on a 2-dimensional grid.  Items have a string name and
coordinates on the grid.  Multiple items can reside at any location,
but each item has a unique name.

The server uses the SSM to manage the grid database.  The server
implements a number of update and query commands.  Update commands on
the grid include adding items, removing items and clearing the grid
(removing all items).  Query commands on the grid including printing the
entire grid, looking up items by name, and locating all items within a
rectangular region of the grid.  There are also commands for committing
and aborting transactions.  The server accepts commands from standard
input and processes remote procedure calls (RPCs) from multiple clients.

The client accepts commands from standard input and sends them to the
server, via remote procedure calls (RPCs) for processing.


\SHsubsubsection{ssmvas:griddemo}{What the Grid Example Demonstrates}

\begin{itemize}
\item Storage facilities

The grid data file and indexes are stored on a single volume as follows.
Each item is stored in a record (containing item name and location)
in an SSM file.  A B+-tree index maps item names to the IDs of the
corresponding item records.  This index is used to lookup items by name.
An R*-tree index maps location coordinates to item records.  This index
is used to locate all items within a rectangular region of the grid.

\item Threads

The grid server is a multi-threaded threaded program that manages
connections from multiple clients and also monitors the terminal
(standard input) for commands.  The server starts a separate thread
for each of these tasks to demonstrate how to use
SSM's thread package.  Shared state among the threads is protected
using the synchronization mechanisms provided by the thread package.

\item Configuration options

The client and server use the SSM's configuration options package
to read configuration information from configuration files
and the program command line arguments.
\end{itemize}

\SHsubsubsection{ssmvas:gridisnot}{What the Grid Example Does Not Demonstrate}

This example does not demonstrate all of the features of the
SSM.  In particular:

\begin{itemize}
\item Appending/truncating records 
\item Pinning large records (longer than 8K bytes) 
\item Gathering statistics
\item Bulk-loading an index
\item Sorting
\item Using sophisticated logical ID features such as inter-volume references
\end{itemize}

Most of the unused features are used in the Shore VAS
(see {\tt src/vas}) and the Paradise database system
(see \htmladdnormallink{http://www.cs.wisc.edu/paradise/}
{http://www.cs.wisc.edu/paradise/}).  Almost every feature is
also tested by the SSM testing program, {\tt ssh}, located in {\tt
src/sm/ssh}.


\SHsubsection{ssmvas:tutorial}{Tutorial Organization}

This tutorial walks through the example program sources in detail.
The sources, as well as associated test programs and data, may be
found in the {\tt src/examples/vas/grid} sub-directory of the distribution.

Throughout this tutorial, we will assume (as does
the \htmldoclink{{\em Shore Software Installation
Manual}}{installation.html}) that the environment variable {\tt \$SHROOT}
contains the absolute path name of the root directory of the installed
Shore software.

The rest of this tutorial is organized as follows.  First, there are two
sections discussing storage structures and operations on them.  Next are
sections explaining how to implement servers and clients.  Finally there
are sections describing how to compile and run the example.

\SHsection{ssmvas:stgstruct}{Storage Structure Organization}

One of the first decisions in designing a server is what
persistent storage structures to use.
This section discusses how we organized storage structures
for the grid example.  There are numerous ways to organized storage.
The primary decision is where to store the information about each item
on the grid.  We first discuss the implemented design and then present
a couple alternatives.

\SHsubsection{ssmvas:chosen}{Implemented Design}

We chose a relational database approach to organizing the data.  Recall
from the introduction that each item has a short string name and a
coordinates on the grid.  Each item is stored in a record.  All item
records are stored in a single file.  Items can be retrieved using
their record ID or by scanning the file.

To improve performance of lookups, we use two indexes.
To support name lookups, we use a B+-tree index mapping
item names to record IDs.  To support lookups on location,
we use an R*-tree mapping an item's coordinates to its record ID.

All files and indexes must be located on a volume.  For the grid
example, only one volume is used.  This volume is located on
a device, the name of which is specified with a configuration option.
When the server starts, it must locate the file and indexes for the
grid.  To support this, the IDs of the file and indexes are stored
in the root index of the volume.  

This design has these desirable properties:
\begin{itemize}
\item
Storage requirements are based on the number of items in the grid,
not the size of the grid.

\item Since each item is stored as a separate record we can
take advantage
of the fine-granularity (record-level) locking provided by the SSM.

\item Adding new indexes is easy.
\end{itemize}

\SHsubsection{ssmvas:alternative}{Alternative Designs }

One alternative design is to store the item
information in a B+-tree index.
The item name is the key and coordinates are the
data associated with the key.

This design has some problems.  First, the R*-tree index would
then map to names, making spatial lookups awkward.
Second, if items are enlarged to hold more data, they may
no longer fit within the size limitation (1-page) of index entries.
Third, to updating the location of an item would mean removing it from
the index and reinserting it, due to a lack of facilities for updating
index entries.

Another alternative design is to treat the grid as a 2-D array of items
and store the entire grid in one large record.  This very
efficient for densely populated grids, but is wasteful for sparse ones.
It would also not support multiple items per location.  Worse yet,
the granularity of locking is the entire grid.


\SHsection{ssmvas:operations}{Operations on Storage Structures}

After deciding on the basic storage structures, we
can begin implementing operations on them.  This section
starts by providing road-map to example code for specific types of
operations.  The code should be self explanatory.
Later sub-sections discuss some of the less obvious aspects of
the implementation.

\SHsubsection{ssmvas:roadmap}{Code Road-map}

\begin{itemize}

\item Volume and Device initialization: {\tt setup\_device\_and\_volume()} in {\tt server.C}

\item Creating Files and Indexes: {\tt command\_server\_t::init()} in
{\tt command\_server.C}

\item Creating Records and Index Entries: {\tt grid\_t::add\_item()} in {\tt grid.C}

\item Destroying Records and Index Entries: {\tt grid\_t::remove\_item()} in {\tt grid.C}

\item Pinning and Updating Records: {\tt grid\_t::move\_item()} in {\tt grid.C}

\item Scanning Files: {\tt grid\_t::generate\_display()} in {\tt grid.C}

\item Index Lookups: {\tt grid\_t::locate\_item()} in {\tt grid.C}

\item Scanning Indexes: {\tt grid\_t::spatial\_query()} in {\tt grid.C}

\end{itemize}


\SHsubsection{ssmvas:initializing}{Initializing Devices and Volumes}

Before creating a storage volume, the {\em device} (raw device or
Unix file) where it will reside must be initialized.
A flag to {\tt setup\_device\_and\_volume()} indicates whether the
device is to be initialized (ie. we're starting from scratch) or
if there is already an initialized device.

If initialization is needed, the device is formatted using {\tt
ss\_m::format\_dev}.  To begin using the device, we mount it with {\tt
ss\_m::mount\_dev}.  Then, create a volume on the device with
{\tt ss\_m::create\_vol}.  Since we will be using the
\htmlextref {SSM's logical ID support} {ssmapi:identifiers}
the {\tt ss\_m::add\_logical\_id\_index} method
must be called to create the index that maps from logical ID
to physical IDs.
The reason the logical ID index is not added automatically by {\tt
ss\_m::create\_vol} is an artifact of the fact that the SSM also has
an interface based on physical IDs (the physical ID interface it not
supported yet).

If no initialization is needed, we mount the device
and use {\tt ss\_m::list\_volumes} to find the ID of the volume
on the device.

The code in {\tt command\_server\_t::init()} uses the
\htmlextref {root index of the volume} {ssmapi:volumes}
to determine if the grid storage structures
have already been created.  If not it creates them.

\SHsubsection{ssmvas:updates}{Updates and Save-points}

All the grid interface commands that update data
involve changing more than one storage structure.
For example, the ``add'' command creates
an item and makes corresponding entries in the name and location indexes.
If any of these operations should fail, it is necessary to 
roll back to the point just before the first operation to keep
the database consistent.
Therefore, the first thing {\tt grid\_t::add\_item} does is
create a save-point using {\tt ss\_m::save\_work}.
If any of the later create operations reports an error,
{\tt ss\_m::rollback\_work} is called.

The use of save-points around all operations that make changes
to storage structures is highly recommended.  That way
even if an {\tt ss\_m} update method should fail, any partial
work it completed is rolled back.  The only other safe choice is
to abort the entire transaction.

\SHsubsection{ssmvas:pinning}{Pinning and Updating Records}

Reading records is accomplished by using the 
\htmlextref{{\tt pin\_i} class}{ssmapi:files}
to pin the record in the buffer pool.  A {\tt pin\_i} object
is often called a ``handle'' to a record.  There are a
couple of things here to keep in mind when using
the {\tt pin\_i} interface.

The {\tt body}
method returns a {\tt const} pointer to the record body.
{\em Never modify the record through these pointers, otherwise
roll back and recovery information will not be generated}.
The most efficient way to modify a pinned record is to use
the {\tt update\_rec}, {\tt append\_rec} and {\tt truncate\_rec}
methods of class {\tt pin\_i} rather than those in {\tt ss\_m} .
If the append or truncate methods cause the record to be moved, the
pin object will continue to point to it.

A record can also be updated using
the {\tt update\_rec}, {\tt append\_rec} and {\tt truncate\_rec}
methods of class {\tt ss\_m}.  However, if the record
is already pinned, the pin object will not be changed
to reflect the update and {\tt pin\_i::repin}
would need to be called.  


\SHsection{ssmvas:multithread}{Implementing a Multi-Threaded Server}

The capability to implement a multi-threaded
server that manages multiple transactions is one of the
distinguishing features of the SSM.  Other persistent storage
systems such as \htmladdnormallink{the Exodus Storage Manager
(http://www.cs.wisc.edu/exodus/)} {http://www.cs.wisc.edu/exodus/})
only allow writing clients that run only one transaction at a time
and are usually single-threaded.

The grid example server is a multi-threaded threaded program that
manages requests from multiple clients, and interactive
commands through its terminal interface.

\SHsubsection{ssmvas:errors}{Error Codes}

Most SSM methods return an error code object of
type {\tt w\_rc\_t} (usually typedef'ed as {\tt rc\_t}.
It is important to always check the return values of these
methods.  To help find places where return codes
are not checked, the
{\tt w\_rc\_t} destructor
has extra code (when compiled with {\tt DEBUG} defined)
to verify that the error code was checked.  An {\tt w\_rc\_t}
is considered checked when any of its methods that read/examine
the error code are
called, including the assignment operator.
Therefore, simply returning an {\tt w\_rc\_t} (which involves
an assignment) is considered checking it.  Of course, the newly
assigned {\tt w\_rc\_t} is considered unchecked.
\htmlextref{More details on error checking}{ssmapi:errorhandling}
are available in the SSM interface document.

The macros {\tt W\_DO} and {\tt W\_COERCE}, declared in {\tt w\_rc.h},
are helpful in checking return values and keeping the code concise.
The {\tt W\_DO} macro takes a function to call, calls it and checks
the return code.  If an error code is returned, the macro executes
a {\tt return} statement returning the error.  The {\tt W\_COERCE}
does the same thing except it exits the program if an error code is
returned by the called function.

Many of the grid methods return {\tt w\_rc\_t} codes as well.
However, the RPC-related methods of {\t command\_server\_t} return
error message strings.  The conversion from {\tt w\_rc\_t} to string
is done by {\tt SSMDO} macro found at the top of {\t command\_server.C}.


\SHsubsection{ssmvas:startup}{Startup}

\SHsubsubsection{ssmvas:config}{Configuration Options}

A number of SSM configuration options must be set before
the SSM is started with the {\tt ss\_m} constructor.  In addition, most
servers, including the grid server, will have options of their own
that need to be set.  The SSM provides an option facility,
\htmlmanlink {options(common)} {options.common.html},
for this purpose.  Included with the option facility are functions to
find options on the program command line and from files of configuration
information.

In {\tt server.C}, {\tt main} creates a 3-level option group
(levels will be discussed shortly), and adds the server's options to
the group with a call to {\tt ss\_m::setup\_options}.  Now the option
group is complete so we call {\tt init\_config\_options} in {\tt
options.C} to initialized the options' values.

The {\tt init\_config\_options} function is used by both the client and
server programs to initialize option values.  The first thing it does
is add classification level names for the option group.   The option
group used for the example has 3 levels.  First level is the
system the program belongs two, in this case {\tt grid}.  The second
is the type of program, in this case {\tt server}.  The third is
the filename of the program executable, which is also {\tt server}.
The classification levels allow options to be set for
multiple programs with a single configuration file.  For
example, both the client and server programs have a {\tt connect\_port}
option for specifying the port clients use to connect to the server.
The following line in a configuration file sets the connection
port so that client and server always agree:

{\tt grid.*.connect\_port: 1234}

The following line would be ignored by the grid programs as
it is for the Shore VAS system:

{\tt shore.*.connect\_port: 1234}

After setting the level names, {\tt init\_config\_options} reads
the configuration file {\tt ./exampleconfig} scanning for options.
Then the command line is searched for any option settings so that
command line settings override those in the configuration file. 
Any option settings on the command line are removed by changing
{\tt argc} and {\tt argv}.

\SHsubsubsection{ssmvas:startingssm}{SSM Initialization}

Once all of the configuration options have been set, the
SSM can be started.  The
\htmlextref{SSM is started by constructing}{ssmapi:initshut}
an instance of the {\tt ss\_m} class (as is done in
{\tt main} in {\tt server.C}).

One of the things the {\tt ss\_m} constructor does is perform recovery,
if necessary.  Recovery will be necessary if a previous server process
crashed before successfully completing the {\tt ss\_m} destructor.

Once the SSM is constructed, {\tt main} calls
{\tt setup\_device\_and\_volume} to initialize the device and volume
as described
htmlextref{above}{ssmvas:initializing}.  With the SSM constructed, we
can now start the threads that do the real work.

\SHsubsection{ssmvas:threadmgmt}{Thread Management}

The grid server manages multiple activities.  It responds to input
from the terminal, listens for new connections from clients, and
processes RPCs from clients.  Any one of these activities can become
blocked while acquiring a lock or performing I/O, for example.
By assigning activities to threads, the entire server
process no longer blocks, only threads do.

The subsections below explain the three types of threads
used by the grid server.  The thread classes are declared in
declared in {\tt rpc\_thread.h} and implemented in {\tt rpc\_thread.C}.
Notice that each thread class is derived from {\tt smthread\_t}.
All threads that use SSM facilities must derived from {\tt smthread\_t}
rather than the base class, {\tt sthread\_t}.

The first code to be executed by any newly forked thread
is its {\tt run} method.  The {\tt run} method is virtual
so that it can be specialized for each type of thread.

\SHsubsubsection{ssmvas:listener}{Listener Thread}

Once the RPC facility has been initialized,
{\tt main} creates a new thread, type {\tt listener\_t},
that listens for client connections.
The listener thread does two jobs:
\begin{itemize}
\item Wait for client connection requests and fork a thread to
handle the connection
\item Manage an orderly shutdown of clients when the {\tt shutdown}
method is called
\end{itemize}

The work of the listener thread is all done in its {\tt run} method
(as is true for all most threads).  The first thing
{\tt run} does is create a file handler ({\tt sfile\_read\_hdl\_t})
for reading from the connection socket.  The code then loops waiting
for input to the socket.  When a connection request arrives, the RPC
function {\tt svc\_getreqset} is called allowing the RPC package to
process the connection request.  Then, a {\tt client\_t} thread
(discussed in the next section) is created to handle the connection.
The new client thread is added to the listener's list of clients.
Notice that since the client list may be accessed by 
multiple threads, it is protected by a 
\htmlmanlink{mutex}{smutex_t.sthread.html}.

When the server is ready to shutdown, {\tt main} calls
{\tt listener\_t::shutdown}, which in turn calls shutdown
on the file handler for the connection socket.  This causes the
listener thread to wakeup and break out of the
while loop in the {\tt run} method.  
The listener then notifies the cleaner thread (see below)
to destroy defunct threads.


\SHsubsubsection{ssmvas:clientthreads}{Client Threads}


When the listener thread detects a new connection
it forks a new thread, type {\tt client\_t},
to process RPC requests on the connection.
The {\tt client\_t} constructor is given a socket on which to wait
for requests and a pointer to the listener thread to notify when
it is finished.  Notice that the client thread has
a buffer area for generating RPC replies, called {\tt reply\_buf}.

The {\tt client\_t::run} method
begins by creating a a file handler ({\tt sfile\_read\_hdl\_t})
for reading from the socket where requests will arrive.
Next, a {\tt command\_server\_t} object is created to process
the requests.

The code then loops waiting for input on the socket.  When an RPC
request arrives the RPC function {\tt svc\_getreqset} is called which
in turn dispatches the RPC to the proper RPC stub function (implemented
in {\tt command\_server.C}).  When the connection is broken, the loop
is exited and the file handler and {\tt command\_server} are destroyed.
Then {\tt listener\_t::child\_is\_done} is called to notify the listener
that the client thread is finally finished.

\SHsubsubsection{ssmvas:cleaner}{Cleaner Thread}

The cleaner thread waits on a condition variable and when
awoken, checks for defunct threads in the
list of client threads.  Any defunct threads found are removed
and destroyed.

Normally it wakes up when a client thread finishes its
{\tt client\_t::run} method, checks the list, and the waits
again on the condition variable {\tt cleanup}.
When the listener thread ends, it causes the cleaner thread
to destroy itself.

\SHsubsubsection{ssmvas:terminal}{Terminal Input Thread}

The main program simply starts a main thread after processing
options.
The {\tt main} thread then takes over the work of the server.
After starting the listener thread,
{\tt main} creates anoter thread, of type {\tt stdin\_thread\_t},
which processes commands from standard input. 

The work of the standard input thread is all done in its {\tt run}
method (as is true for all most threads).  The first thing {\tt
run} does is create a file handler ({\tt sfile\_read\_hdl\_t})
for reading from the file descriptor for standard input.  Next, a
{\tt command\_server\_t} object is created to process the commands.
The code then loops waiting for input.  When input is ready, a line
is read and fed to {\tt command\_server\_t::parse\_command} for
processing.  If {\tt parse\_command} indicates that the quit command
has been entered or if EOF is reached on standard input, the input
loop is exited and the thread ends.


\SHsubsection{ssmvas:xct}{Transaction and Lock Management}

The grid server uses a simple transaction management scheme.
All operations on data managed by the SSM must be done within the scope
of a transaction.  Each client thread starts a transaction for the
client it manages.  Clients decide when to end (either commit or abort)
the transaction.  When this occurs a new one is automatically started by
the grid server.  If a client disconnects from the server, its current
transaction is automatically aborted.

The SSM automatically acquires locks when data is accessed, providing
serializable transactions.  The grid server relies on
the automatic locking done by the SSM.  One example of where the server
explicitly acquires locks is in the {\tt grid\_t::clear} method, which
removes every item from the database.  Here we acquire an EX lock on
the item file and indexes to avoid the overhead of acquiring finer
granularity locks.

More sophisticated transaction and locking schemes are possible. 
For example, the {\tt grid\_t::generate\_display} method (used by
the print command) locks the entire file containing items,
thus preventing changes to the grid.  For greater concurrency, it is
possible to have {\tt generate\_display} start a separate transaction
before scanning the item file.  Afterward, it can commit the
transaction, releasing the locks on the file.  To do this the client
uses the {\tt smthread\_t::attach} method to attach
to the original client transaction.

Another way to get a similar effect is to use the {\tt
t\_cc\_none} flag to the concurrency control ({\tt cc}) parameter of
the {\tt scan\_file\_i} constructor.

\SHsubsection{ssmvas:rpc}{RPC Implementation}

At the heart of the grid system are the RPCs called by the client and
serviced at the server.  We use the publicly available Sun RPC package
to implement the RPCs.

\SHsubsubsection{ssmvas:decl}{Declarations}

The RPCs are declared in {\tt msg.x}.  This includes {\tt
grid\_basics.h} which contains some additional declarations used throughout
the grid code.  The first part of {\tt msg.x} contains declarations
for structures use to hold RPC arguments and return values, followed
by a listing of the RPCs.  The final part of the file contains ANSI-C
style function prototypes for the server and client side RPC stubs
since the RPC package does not generate them.

The {\tt msg.x} file is processed by the {\tt rpcgen} (see rpcgen(1)
manual page) utility to create the following files:
\begin{itemize}
\item {\tt msg\_clnt.c}: client-side stubs for the RPCs
\item {\tt msg\_svc.c}: server-side dispatch routine
\item {\tt msg.h}: declarations used by both the client and server
\item {\tt msg\_xdr.c}: xdr functions
\end{itemize}

\SHsubsubsection{ssmvas:cxxwrap}{C++ Wrappers}

The output of {\tt rpcgen} is inconvenient for two reasons: it 
is is C not C++ and the client stubs take
different parameters than those of the server.  Therefore, we
encapsulate the RPCs in the abstract base class {\tt command\_base\_t}
declared in {\tt command.h}.  The pure virtual functions in this
class represent RPCs.
Class {\tt command\_client\_t} (in {\tt command\_client.h}) 
is derived from {\tt command\_base\_t}
and implements the client side of the
RPCs by calling the C routines in {\tt msg\_clnt.c}.  Also derived
from {\tt command\_base\_t} is {\tt command\_server\_t} (in
{\tt command\_server.h}) that implements the server side of the RPCs.

The server-side C stubs for the RPCs, implemented in
{\tt server\_stubs.C}, call corresponding
{\tt command\_server\_t} methods.

The only function that makes RPC requests is
{\tt command\_base\_t::parse\_command}.  It parses a command line
and calls the appropriate {\tt command\_base\_t} method implementing
the RPC.

To process RPC requests on the server, an instance of {\tt
command\_server\_t} is created for each client thread.  When an RPC
arrives, the thread managing the client is awakened and the RPC dispatch
function in {\tt msg\_svc.c} is called.  This calls the server-side C
stub which in turn calls the corresponding {\tt command\_server\_t}
method.  The methods in {\tt command\_server\_t} call {\tt grid\_t}
methods (in {\tt grid.C}) to access and update the grid database.

To execute commands on the server,
an instance of {\tt command\_server\_t} is created for the
thread managing standard input.  This thread calls
{\tt command\_base\_t::parse\_command} for each line of
input.  The parse {\tt parse\_command} method
calls the {\tt command\_server\_t} methods, short-circuiting
the RPC facility.

\SHsubsubsection{ssmvas:rcpstart}{RPC Startup}

Once the SSM and volumes are initialized, the grid server is ready to
start the RPC service and begin listening for connections from clients.
RPC start-up is done by the function {\tt start\_tcp\_rpc} in {\tt
server.C}.  This function creates the socket used to listen
for connection requests, binds a port to the socket, and then 
calls RPC facility's initialization functions.

\SHsubsubsection{ssmvas:multithread2}{Multi-threading Issues}

The multi-threaded environment of the server requires changes
to a couple common practices in Sun RPC.

Replies are usually placed in a statically allocated structure.
With multiple threads, each threads needs its own space for
replies, so a reply area is created for each thread as
described 
\hyperref{above}{in Section}{}{ssmvas:clientthreads}.

The RPC package allocates ({\tt malloc}s) space for pointer
arguments in RPCs.  The convention is that the function
processing a request frees the space from the previous request of the
same type.  Because the convention requires that the reply be saved
in static storage,
this does not work in a multi-threaded environment.
The Sun RPC package shipped with the Shore release has modified
{\tt rpcgen} to generate a dispatch routine that
automatically 
frees the space after the reply is sent, relieving the function
of the burden of freeing the space.
Because of this change, the library
does not lend itself
to saving replies for the purpose of retransmitting them
in response to duplicate requests (for the UDP service).


\SHsubsubsection{ssmvas:newrpc}{Steps to add a New RPC}

As an example.  of how to add an RPC we explain how the {\tt locate}
command was added to the grid example.

\begin{itemize}

\item Add argument and reply types to {\tt msg.x}.

The argument type for the locate command is {\tt location\_arg}
and the reply type is {\tt location\_reply}.  The constant,
{\tt thread\_reply\_buf\_size} must also be changed to reflect
the size of the {\tt location\_reply} structure.

\item Add RPC and stub declarations to {\tt msg.x}.

The RPC is called {\tt location\_of\_rpc} and is listed in the {\tt
program} section of {\tt msg.x}.   Below this are declarations
for the client and server-side stubs.

\item Add declaration to {\tt command.h}, {\tt command\_server.h} and
{\tt command\_client.h}.

Recall that there are C++ wrapper methods for the RPCs in 
the abstract base class {\tt command\_base.h} and its derived classes.
So, declarations for the RPC wrapper method must be added to them.  
We used the method name {\tt location\_of}.

\item Implement wrapper method in {\tt command\_client.C}.

The client side of {\tt location\_of} must call the 
RPC stub, {\tt location\_of\_rpc\_1}.

\item Implement server stub to call the wrapper method in {\tt server\_stubs.C}.

The server-side stub for the RPC, {\tt location\_of\_rpc\_1}, must call
the wrapper method, {\tt command\_server\_t::location\_of}.

\item Implement wrapper method in {\tt command\_server.C}.

The wrapper method implements the RPC by called a corresponding method
of the {\tt grid\_t} class.  It converts any error into a string
to be sent in the reply.

\item Implement the {\tt location\_of} method in {\tt grid.C}.

All access to the grid database is done by methods of {\tt grid\_t}.
Therefore there is a {\tt location\_of} method that does the actual
index lookup to find the location of an item.  Of course, a declaration
for {\tt location\_of} must be added to {\tt grid.h}.

\item Add locate command to parser in {\tt command.C}.

Implemented in {\tt command.C} is {\tt
command\_base\_t::parse\_command}, which parses a command line and calls
the the RPC's C++ wrapper.  To add the command, edit the {\tt enum}
for command tokens and the array of command descriptions.  Then add
the command to the {\tt switch} statement in {\tt parse\_command}.

\end{itemize}

\SHsubsection{ssmvas:shutdown}{Shutdown}

Shutting down the SSM involves ending all threads, except the
one running {\tt main} and then destroying the {\tt ss\_m} object.
After {\tt main} starts the thread for commands on the terminal,
main calls {\tt wait} on the thread.  When the {\tt quit} command
is entered, the terminal thread ends causing {\tt wait} to return,
thus waking up the main thread.  {\tt Main} then tells the listener
listener thread to shutdown and does a {\tt wait} for it.  The shutdown
process for the listener thread is described \hyperref{above}{in
Section}{}{ssmvas:listener}.  The main thread wakes up when the listener
thread is done.  The final shutdown step is to {\tt delete} the instance
of the class {\tt ss\_m} created at the beginning of {\tt main}.


\SHsection{ssmvas:implclients}{Implementing Clients}

The client is simpler than the server.
It is single threaded and calls server RPCs to do most work.
It uses the the configuration options and error handling facilities
of the SSM similar to the server use of them. 

This section focuses on RPC issues. 

\SHsubsection{ssmvas:cxmgmt}{Connection Management}

The code for connection management is all in file {\tt client.C}.
The function {\tt connect\_to\_server} connects to a server
at a specific host and port.  The original Sun RPC package has
no direct support for this since it assumes you will use
the {\tt port mapper} facility.  However, the Shore version
of the package has a {\tt clnt\_create\_port} function that
could replace most of the code in {\tt connect\_to\_server}.

The function {\tt disconnect\_from\_server} demonstrates how
to end a session with the server.

\SHsubsection{ssmvas:clientrpc}{Client Side of RPCs}

The client-side stubs for the RPCs are generated by {\tt rpcgen}
and placed in {\tt msg\_clnt.c}.  
\htmlextref{Recall}{ssmvas:cxxwrap}
that
we wrap the RPCs in C++ methods from the {\tt command\_base\_t} 
abstract base class.  From that class we derive {\tt command\_client\_t}
and implement the methods by calling the RPC stubs.

In {\tt client.C} the function {\tt process\_user\_commands} 
creates an {\tt command\_client\_t} object, reads lines from
standard input, and calls {\tt command\_client\_t::parse\_command}
for each line.  Method {\tt parse\_command} in turn calls
the {\tt command\_client\_t} wrapper methods.

\SHsection{ssmvas:compiling}{Compiling the Example}

To compile the grid example, you should first copy example/vas/grid to
a new location.  The file
\hyperref {{\tt Makefile.template}}{{\tt Makefile.template}}{}{ssmvas:makefile}
is a sample Makefile
for building the example program.  Copy it to {\tt Makefile} and edit
it to set {\tt INSTALL\_DIR} to the root of the Shore installation
directory (\$SHROOT).  Then run {\tt make}.
You should see something like this:
\begin{verbatim}

    SHROOT/rpcgen msg.x
    rm -f msg_svc.c
    SHROOT/rpcgen  -m -o msg_svc.c msg.x 

    g++ -g -O -I/p/shore/installed.new/nodebug/include -Wall
	      -fno-implicit-templates -c grid.C

    ...
\end{verbatim}

Notice that the modified {\tt rpcgen} shipped with Shore is used
by default.  When the compilation is complete, you should have a two
executables, {\tt server} and {\tt client}.


\SHsection{ssmvas:running}{Running the Example}

The configuration options for the server and client can be
set in the file {\tt exampleconfig} or on the command line.
You must edit {\tt exampleconfig} to set the {\tt sm\_diskrw}
option to the location of the installed {\tt diskrw} program.
Information about all the options available to the programs
can be found by running them with a {\tt -h} flag.

The first thing to do is to run {\tt server -i} to format and make the
volumes containing the grid data.  Next, type {\tt client} to start
a client.  At either the client or server prompt, you can type {\tt
help} to get this list of available commands:

\begin{verbatim}

Server> help
Valid commands are: 

    commit 
        commit transaction and start another one
    abort 
        abort transaction and start another one
    clear 
        clear grid
    print 
        print grid
    add name x y
        add new item <name> at <x,y>
    remove name
        remove item <name>
    locate name
        print location of item <name>
    spatial x_lo y_lo x_hi y_hi
        print count of items in rectangle and list first few items
    quit 
        quit and exit program (aborts current transaction)
    help 
        prints this message

    Comments begin with a '#' and continue until the end of the line.

\end{verbatim}

At all times a transaction is running for the server and
client prompts.  As commands are run, appropriate locks are
obtained.  Locks will be released when a commit or abort
command is given. 

Here are some commands you might try:

\begin{verbatim}

print 			# print the empty grid
add Junk 20 10		# add and item named Junk at coordinate 20,10
add Car 15 5
print
commit			# commit the current transaction
locate Car		# find location of Car
spatial 0 0 39 14	# count all items on grid
spatial 20 10 20 10	# list all items at location 20,10
clear			# clear the grid
print			# it should be empty
abort			# abort the current transaction
print			# grid should have items on it now
quit			# quit -- aborts current transaction

\end{verbatim}


\SHsection{ssmvas:apx}{Appendix:  Program Sources}

\begin{latexonly}

Program sources are not included in the Postscript version
due to their length.  The sources can be found in {\tt
SHROOT/examples/vas/grid}.

\end{latexonly}

\begin{htmlonly}

\SHsubsection{ssmvas:sharedcode}{Code Shared by Client and Server}
\SHsubsubsection{ssmvas:makefile}{Makefile: Makefile.template}
htmlinclude Makefile.template
\SHsubsubsection{ssmvas:msgx}{RPC Declarations: msg.x}
htmlinclude msg.x
\SHsubsubsection{ssmvas:gridbasicsh}{grid\_basics.h}
htmlinclude grid_basics.h
\SHsubsubsection{ssmvas:gridbasicsC}{grid\_basics.C}
htmlinclude grid_basics.C
\SHsubsubsection{ssmvas:commandh}{command.h}
htmlinclude command.h
\SHsubsubsection{ssmvas:commandC}{command.C}
htmlinclude command.C
\SHsubsubsection{ssmvas:optionsC}{Configuration Options: options.C}
htmlinclude options.C

\SHsubsection{ssmvas:servercode}{Server Code}

\SHsubsubsection{ssmvas:serverC}{Main: server.C}
htmlinclude server.C
\SHsubsubsection{ssmvas:commandserverh}{command\_server.h}
htmlinclude command_server.h
\SHsubsubsection{ssmvas:commandserverC}{command\_server.C}
htmlinclude command_server.C
\SHsubsubsection{ssmvas:serverstubsC}{server\_stubs.C}
htmlinclude server_stubs.C
\SHsubsubsection{ssmvas:gridh}{grid.h}
htmlinclude grid.h
\SHsubsubsection{ssmvas:gridC}{grid.C}
htmlinclude grid.C
\SHsubsubsection{ssmvas:rpcthreadh}{rpc\_thread.h}
htmlinclude rpc_thread.h
\SHsubsubsection{ssmvas:rpcthreadC}{rpc\_thread.C}
htmlinclude rpc_thread.C

\SHsubsection{ssmvas:clientcode}{Client Code}

\SHsubsubsection{ssmvas:clientC}{Main: client.C}
htmlinclude client.C
\SHsubsubsection{ssmvas:commandclienth}{command\_client.h}
htmlinclude command_client.h
\SHsubsubsection{ssmvas:commandclientC}{command\_client.C}
htmlinclude command_client.C

\end{htmlonly}


\end{document}
