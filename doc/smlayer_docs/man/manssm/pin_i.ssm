.TH pin_i ssm "Jan 1999" "Release \*(SV" "Shore Storage Manager" "Release 2.0" "Shore Storage Manager Reference Manual"
.so tmac.man.local
.SH NAME
pin_i, pin, repin, unpin \- Class for Pinning Records
.SH SYNOPSIS
.EX
#include <sm_vas.h>  // which includes pin.h

class pin_i : public smlevel_top {
public:
    enum flags_t { 
	pin_empty		= 0x0,
	pin_rec_pinned		= 0x01,
	pin_hdr_only		= 0x02, 
	pin_separate_data	= 0x04,
	pin_lg_data_pinned	= 0x08  // large data page is pinned
    };
    
    NORET		pin_i();
    NORET		~pin_i();

    /* Logical-ID version */
    rc_t	   	pin(
	const lvid_t&	    lvid,
	const serial_t&	    lrid,
	smsize_t	    start,
	lock_mode_t	    lmode = SH);

    /* Physical-ID version */
    rc_t        pin(
        const rid_t         rid,
        smsize_t            start,
        lock_mode_t         lmode = SH);


    void   		unpin();
    void                set_ref_bit(int value);
    rc_t    		repin(lock_mode_t lmode = SH);
    rc_t		next_bytes(bool& eof); 
    bool  		pinned() const;
    bool  		pinned_all() const;
    bool		up_to_date() const;

    // methods for accessing the record
    smsize_t   		start_byte() const;
    smsize_t   		length() const;
    smsize_t   		hdr_size() const;
    smsize_t   		body_size() const;
    const char*     	hdr() const;
    const char*     	body();
    bool  		is_small() const;
    const record_t* 	rec() const;
    const serial_t&	serial_no() const;
    const lvid_t&	lvid() const;
    const rid_t&	rid() const;

    // methods for changing the record
    rc_t    		update_rec(smsize_t start, const vec_t& data);
    rc_t    		update_rec_hdr(smsize_t start, const vec_t& hdr);
    rc_t    		append_rec(const vec_t& data);
    rc_t    		truncate_rec(smsize_t amount);

    // miscellaneous   
    const char* 	hdr_page_data();
    lpid_t 		page_containing(
	smsize_t	    offset,
	smsize_t&	    start_byte) const;
    static void 	pin_stats(
	u_long&		    pins,
	u_long&		    unpins,
	bool		    reset);

private:
    // these methods are disabled
    pin_i(const pin_i&);
    pin_i& operator=(const pin_i&);
};

.EE
.SH DESCRIPTION
Class
.FN pin_i
supports pinning
records
in the buffer pool and provides
a variety of methods for accessing information about a
record and its contents.  A
.FN pin_i
object is basically a handle to a pinned record.  
The _i suffix in a class name indicates that a class is an iterator.
Class
.FN pin_i
is an iterator since it is used to iterate over all by bytes
in a record's body.

.SH CONSTRUCTORS and DESTRUCTORS

.LP
.B "pin_i()"
.IP
The
.FN pin_i
constructor simply initializes a pin_i object.
.LP
.B "~pin_i()"
.IP
If a record is pinned,
.FN ~pin_i
un-pins it.

.SH PINNING

.LP
.B "pin(lvid, lrid, start, lmode)"
.IP
The
.FN pin
method pins a range of bytes of a record.
For small records (those
that fit on one page), the entire record body will be pinned.  For large
records, only one page of the body will be pinned at a time.
For both small and large records, the
record header is always pinned as well. 
The first two parameters, 
.VA lvid
and
.VA lrid
specify the
.HR "logical ID" "lid_t.common.html"
of the record to be pinned.
.LP
.IP
The
.VA start
parameter
specifies a byte offset into the record body corresponding to a region
of the body to pin.  However, the pin operation will always
adjust the starting location of the pin to reflect the beginning
of the page containing the byte indicated by the
.VA start
parameter.  The true starting location and size of the pinned
region are available from the 
.FN start_byte
and
.FN length
methods, respectively.
For example,
.VA start=0
will always pin the first page of the record body, as will
.VA start=10
(assuming the record is at least 10 bytes long).  In both cases,
.FN start_byte
will return 0 and length will either the entire
record, if small, or approximately the
length of a page, if large.
.LP
.IP
The
.VA lmode
parameter specifies how the record should initially be locked
(ie. the lock mode).  The options are
.FN SH
(share/read lock)
and
.FN EX
(exclusive/write lock).
.FN EX should be used when
the pinned record will be eventually updated (through update_rec,
unpdate_rec_hdr, append_rec, or truncate_rec).  Using EX in these
cases will improve performance and reduce the risk of deadlock,
but is not necessary for correctness.

.LP
.B "unpin()"
.IP
The
.FN unpin
method unpins the current record (assuming one is pinned).  The
pin object can then be used to pin another record.  The destructor
automatically calls
.FN unpin.

.LP
.B "set_ref_bit(value)"
.IP
The
.FN set_ref_bit
sets the reference bit
.VA value
to use for the buffer frame containing the currently pinned
body page when the page is unpinned.  A
.VA value
of 0 is a "hate" hint indicating that
the frame can be reused as soon as necessary.  By default, a
.VA value
of 1 is used indicating the page will be cached 
until at least 1 sweep of the buffer clock hand has passed.
Higher values cause the page to remain cached longer.

.LP
.B "repin(lmode)"
.IP
The
.FN repin
method repins the previously pinned record, locking it in the
mode specified by
.VA lmode
(see
.FN pin
for further discussion of
.VA lmode.
The repin method has a number of uses.  First, when
the previously pinned record needs to be repinned,
it is more efficient to call
.FN repin
than to call 
.FN pin
with the ID of the record.
Second, it can be used to repin the record after some other
operation has modified the page containing the record.  See
the
.B RESTRICTIONS
section
for further information on this use of
.FN repin.
Third, repin can be used to upgrade the lock held on the 
currently pinned record.
However, this is usually unnecessary since all of the 
methods in class
.FN pin_i
that modify the record will automatically acquire an
.FN EX
mode lock on the record.

.LP
.B "next_bytes(eof)"
.IP
The
.FN next_bytes
method gets the next range of bytes available to be pinned.
Parameter
.VA eof
is set to
.B true
if there are no more bytes to pin.
When eof is reached, the previously pinned range remains pinned

.LP
.B "pinned()"
.IP
The
.FN pinned
methods returns
.B true,
if a record is currently being pinned, and
.B false
otherwise.

.LP
.B "pinned_all()"
.IP
The
.FN pinned_all
methods returns
.B true
if the pinned region includes the entire record, otherwise.
.B false
is returned.

.LP
.B "up_to_date()"
.IP
The
.FN up_to_date
method returns
true if a record is pinned and pin no changes have been made
to the page containing the record since it was pinned.
See the
.B RESTRICTIONS
section for information on using this method.

.SH ACCESSING THE RECORD

.LP
.B "start_byte()"
.IP
The
.FN start_byte
method returns the offset, from the beginning of the record, where
the pinned region starts.  Ie. it is the offset of the location
pointed to by the
.FN body
method.
.B Note:
the value returned by 
.FN start_byte
may not be the
.VA start
location passed to
.FN pin
since pinned regions are always aligned on page boundaries. 

.LP
.B "length()"
.IP
The
.FN length
method returns the length, in bytes, of the pinned region.

.LP
.B "hdr_size()"
.IP
The
.FN hdr_size
method returns the size, in bytes, of the record header.

.LP
.B "body_size()"
.IP
The
.FN body_size
method returns the size, in bytes, of the entire record body
(not just the portion pinned).

.LP
.B "hdr()"
.IP
The
.FN hdr
method returns a pointer to the pinned header.  Note that the
pointer is
.B const
since the header can only be updated via
.FN update_rec_hdr.

.LP
.B "body()"
.IP
The
.FN body
method return a pointer to the pinned region of the body.
Note that the
pointer is
.B const
since the body can only be updated via the update methods
described below.

.LP
.B "is_small()"
.IP
The
.FN is_small
method returns
.B true
if the record body fits on the same page as the header and thus is
pinned in it's entirety.


.LP
.B "serial_no()"
.LP
.B "lvid()"
.IP
The
.FN serial_no
and
.FN lvid
methods
return the logical ID of the pinned
record assuming it was pinned using logical IDs. 
.B Note:
theses IDs are the "snapped" values -- ie. they
are the volume ID where the record is located and
the record's serial# on that volume.  Therefore, these
may be different than the ones passed in to pin the
record.

.LP
.B "rid()"
.IP
The
.FN rid
method return the physical ID of the record.

.LP
.B "rec()"
.IP
The
.FN rec
method returns the pointer
.FN record_t
structure that is used internally to access records on 
pages.  Most uses of this structure, such as finding the size of
the record, are already provided by other
.FN pin_i
methods.  
The primary use of this method is debugging or to do things
not provided by other
.FN pin_i
methods.

.SH UPDATING A PINNED RECORD

.LP
.B "update_rec(start, data)"
.LP
.B "update_rec_hdr(start, hdr)"
.LP
.B "append_rec(data)"
.LP
.B "truncate_rec(amount)"
.IP
These methods are used to change a pinned record.  They
correspond to the class
.FN ss_m
methods of the same name
describe in 
.SA file(ssm).
They can be called on any pinned record
regardless of where and how much is pinned.
Using these methods when a record is pinned is 
considerably more efficient than calling the corresponding
.FN ss_m
methods.
Also, the
.FN up_to_date
method will return
.B true
after calling one of these methods, even though they update
the record.

.SH OTHER MEMBER FUNCTIONS

.LP
.B "hdr_page_data()"
.IP
The
.FN hdr_page_data
method returns a pointer to beginning of the page containing
the pinned record header.  This is used by the Shore VAS
when sending entire pages of records to the client. 
A page can be interpreted with the
.B shore_file_page_t(ssm)
class (undocumented).

.LP
.B "page_containing(offset, start_byte)"
.IP
The
.FN page_containing
returns the page ID of the page containing the
.VA start_byte
offset from the beginning of the record body.
This function is not currently supported.

.LP
.B "pin_stats(pins, unpins, reset)"
.IP
The
.FN pin_stats
method return the number of pins and unpins performed.
The
.VA pins
parameter will equal the sum of all
.FN pin
and 
.FN repin
calls.  The
.VA unpins
parameter will equal the sum of all
.FN unpin
.FN repin
calls.

.SH CAVEATS

.LP
While a pin_i is valid, a page is fixed in the buffer pool.
Pages should not be fixed for long periods of time, and a
thread that pins multiple pages in the buffer pool runs the
risk of exhausting the buffer pool resources.
.LP
It is risky to pin and update two records concurrently, that is,
to update one record while another record is
pinned.  If the records are on the same page, updating one
record can invalidate the pin of the other record.
The method
.FN repin
can be used to re-validate the pin of the second record, 
however, it is still a risky proposition: read on.
.LP
On the other hand, if the two records are on different pages, 
and if the thread is not observing a protocol to order the pins,
(more importantly, all threads in the VAS must observe 
the same protocol), 
.B "latch-latch deadlocks"
can occur (pages are
latched when they are fixed), if
fine-grained (record) locking is in effect.
Whereas deadlock detection is performed on locks, latches are
much lighter-weight and do not perform deadlock detection.

.SH ERRORS

To Do.

.SH EXAMPLES
To Do.

.DA
.SH "SEE ALSO"
.SA file(ssm),
.SA scan_file_i(ssm),
.SA intro(ssm),

