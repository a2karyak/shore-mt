.TH smthread_t ssm "Jan 1999" "Release \*(SV" "Shore Storage Manager" "Release 2.0" "Shore Storage Manager Reference Manual"
.so tmac.man.local
.SH NAME
smthread_t \- SSM Thread Class

.SH SYNOPSIS
.EX

#include <sm_vas.h>  // which includes smthread.h

typedef void st_proc_t(void *);

class smthread_t : public sthread_t {
public:
    NORET			smthread_t(
	st_proc_t* 		    f,
	void* 		            arg,
	priority_t 		    priority = t_regular,
	bool 			    block_immediate = false, 
	bool 			    auto_delete = false,
	const char* 		    name = 0,
	long 			    lockto = WAIT_FOREVER);

    NORET			smthread_t(
	priority_t 		    priority = t_regular,
	bool 			    block_immediate = false, 
	bool 			    auto_delete = false,
	const char* 		    name = 0,
	long 			    lockto = WAIT_FOREVER);

    NORET			~smthread_t();

    virtual void 		run() = 0;
    
    void 			attach_xct(xct_t* x);
    void 			detach_xct(xct_t* x);
    xct_t* 			xct();
    const xct_t* 		const_xct() const;
    static smthread_t* 		me();

    // set and get lock_timeout value
    long 			lock_timeout() const;
    void 			lock_timeout(long i);

    /*
     *  These methods are used to verify than nothing is
     *  left pinned accidentally.  Call mark_pin_count before an
     *  operation and check_pin_count after it with the expected
     *  number of pins that should not have been released.
     */
    void 			mark_pin_count();
    void 			check_pin_count(int change);
    void 			check_actual_pin_count(int actual) ;
    void 			incr_pin_count(int amount) ;
   
    /*
     *  These methods are used to verify that a thread
     *  is only in one ss_m::, scan::, or pin:: function at a time.
     */
    void 			in_sm(bool in);
    bool 			is_in_sm() const;

private:
    void			user(); /* disabled sthread_t::user */
};


.EE

.SH DESCRIPTION

Class
.FN smthread_t
inherits from 
.FN sthread_t,
and extends it for use by the higher layers of the 
Shore Storage Manager.  Any thread calling methods
documented in
.VA ssm
section manual pages (see
.SA intro(ssm)
for a list) must be an
.FN smthread_t
or derived from it.

.LP
.FN "sthread_t(priority, block_immediate, auto_delete, name, lock_timout)"
.IP
See
.SA sthread_t(sthread)
for details on the
.VA priority,
.VA block_immediate,
.VA auto_delete
and
.VA name
parameters.
The
.VA lock_timout
parameter specifies the default for how long a lock
request by the smthread should block before it times out.

.LP
.FN "run()"
.IP
This method is the body of the thread.  See
.SA sthread_t(sthread)
for more details.  Users must provide their own 
.FN run
method.

.SS Methods pertinent to Transactions
.LP
Threads often run on behalf of a transaction, so there are
methods for associating a thread with a transaction.  
For more information on transactions, see
.SA transaction(ssm)

.LP
.FN "attach_xct(xct)"
.IP
The
.FN attach_xct
method attaches the thread to transaction
.VA xct.
Any SSM operation, performed by this thread,
that requires transaction information will use the
.VA xct
transaction.  For example, all locks acquired by operations
will be for the 
.VA xct
transaction.
The 
.FN ss_m::begin_xct
method automatically calls 
.FN attach_xct.
It is a fatal error to call
.FN attach_xct
if the thread is already attached to a transaction.

.LP
More than one thread can operate on behalf of a
given transaction at any time, but certain
transaction-related activities are serialized 
with a synchronization variable.  For example,
only one of the threads can be writing log records
for a top-level (compensated) operation at any time.
Another example of such serialization involves the
lock manager: if any single thread of a multi-threaded
transaction waits on a lock, all of the transaction's
threads that would block in the lock manager wait on 
the same lock (regardless what locks they are trying to 
acquire).

.LP
A VAS that attaches a transaction to more than one thread 
runs a high risk of getting latch-latch deadlocks among
threads.  It is the responsibility of the VAS to implement
its own protocol for avoiding these deadlocks.
An example of such a protocol is to allow threads of 
multi-threaded transactions
to work on non-overlapping partitions of the database.
.LP
It is also the responsibility of the VAS to see that
certain operations, including commit and abort,
are not attempted while a transaction
is attached to several threads.

.LP
.FN "detach_xct(xct)"
.IP
The
.FN detach_xct
method detaches the thread from transaction
.VA xct.
It is a fatal error if the thread is not already attached to
.VA xct.

.LP
.FN "xct()"
.IP
The
.FN xct
method returns the transaction to which the thread is currently
attached.


.SH ERRORS

TODO

.SH EXAMPLES

See
.HR "Writing Value-Added Servers with the Shore Storage Manager" "../ssmvas/ssmvas.html"
for an example of how to use threads in a server.


.DA

.SH SEE ALSO

.SA intro(sthread)
.SA sthread_t(sthread)
.SA transaction(ssm)
.SA lock(ssm)

