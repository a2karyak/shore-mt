.TH ss_m::index ssm "Jan 1999" "Release \*(SV" "Shore Storage Manager" "Release 2.0" "Shore Storage Manager Reference Manual"
.so tmac.man.local
.SH NAME
bulkld_index, create_assoc, create_index, destroy_assoc, destroy_index, find_assoc, print_index \- Class ss_m Methods for B+Tree Index Operations
.SH SYNOPSIS
.EX
#include <sm_vas.h>  // includes sm.h (where they are declared)

    /* Logical-ID version */
static rc_t                 create_index(
    const lvid_t&               lvid,
    ndx_t                       ntype,
    store_property_t            property,
    const char*                 key_desc,
    concurrency_t               cc,
    uint                        size_kb_hint,  // hint on final size in KB
    serial_t&                   liid);

    /* Physical-ID version */
static rc_t                 create_index(
    vid_t                       vid,
    ndx_t                       ntype,
    store_property_t            property,
    const char*                 key_desc,
    concurrency_t               cc,
    stid_t&                     stid,	// result
    const serial_t&             logical_id=serial_t::null
    );


    // for backward-compatibility:
    /* Logical ID version */
static rc_t                 create_index(
    const lvid_t&               lvid,
    ndx_t                       ntype,
    store_property_t            property,
    const char*                 key_desc,
    uint                        size_kb_hint,  // hint on final size in KB
    serial_t&                   liid);


    // for backward compatibility:
    /* Physical-ID version */
static rc_t                 create_index(
    vid_t                       vid,
    ndx_t                       ntype,
    store_property_t            property,
    const char*                 key_desc,
    stid_t&                     stid,
    const serial_t&             logical_id=serial_t::null
    );

    /* Logical ID version */
static rc_t                 destroy_index(
    const lvid_t&               lvid,
    const serial_t&             liid);

    /* Physical-ID version */
static rc_t                 destroy_index(
    const stid_t& 		iid);


    /* Logical ID version */
static rc_t                 bulkld_index(
    const lvid_t&               lvid,
    const serial_t&             liid,
    const lvid_t&               s_lvid,
    const serial_t&             s_lfid,
    sm_du_stats_t&              stats);

    /* Physical-ID version */
static rc_t                 bulkld_index(
    const stid_t&               stid,
    const stid_t&               source,
    sm_du_stats_t&              stats,
    bool                        sort_duplicates = true,
    bool                        lexify_keys = true
    );
    /* Physical-ID, variant of above with multiple input files */ 
static rc_t                 bulkld_index(
    const stid_t&               stid,
    int                         nsrcs,
    const stid_t*               source,
    sm_du_stats_t&              stats,
    bool                        sort_duplicates = true,
    bool                        lexify_keys = true
    );


    /* Logical ID version */
static rc_t                 bulkld_index(
    const lvid_t&               lvid,
    const serial_t&             liid,
    sort_stream_i&              sorted_stream,
    sm_du_stats_t&              stats);

    /* Physical-ID version */
static rc_t                 bulkld_index(
    const stid_t&               stid,
    sort_stream_i&              sorted_stream,
    sm_du_stats_t&              stats);


    /* Logical ID version */
static rc_t                 print_index(
    const lvid_t&               lvid,
    const serial_t&             liid);

    /* Physical-ID version */
static rc_t                 print_index(
    stid_t 			stid);


    /* Logical ID version */
static rc_t                 create_assoc(
    const lvid_t&               lvid,
    const serial_t&             liid,
    const vec_t&                key,
    const vec_t&                el);

    /* Physical-ID version */
static rc_t                 create_assoc(
    stid_t                      stid,
    const vec_t&                key,
    const vec_t&                el
    );


    /* Logical ID version */
static rc_t                 destroy_assoc(
    const lvid_t&               lvid,
    const serial_t&             liid,
    const vec_t&                key,
    const vec_t&                el);

    /* Physical-ID version */
static rc_t                 destroy_assoc(
    stid_t                      stid,
    const vec_t&                key,
    const vec_t&                el
    );


    /* Logical ID version */
static rc_t                 destroy_all_assoc(
    const lvid_t&               lvid, 
    const serial_t&             liid,
    const vec_t&                key,
    int&                        num_removed);

    /* Physical-ID version */
static rc_t                 destroy_all_assoc(
    stid_t                      stid,
    const vec_t&                key,
    int&                        num_removed
    );


    /* Logical ID version */
static rc_t                 find_assoc(
    const lvid_t&               lvid,
    const serial_t&             liid,
    const vec_t&                key,
    void*                       el,
    smsize_t&                   elen,	// if you don't want the result,
                                       // make this 0 on input
    bool&                       found);

    /* Physical-ID version */
static rc_t                 find_assoc(
    stid_t                      stid,
    const vec_t&                key,
    void*                       el,
    smsize_t&                   elen,
    bool&                       found
    );



.EE
.SH DESCRIPTION

The above class
.FN ss_m
methods manipulate B+tree indexes.

.SS Common Parameters
.LP 
There are a number of common parameters for these methods:
.IP lvid 5
Logical volume ID of volume containing an index.
.IP liid 5
Logical index ID, the serial number of an index.
(The Physical-ID versions of these methods take a store ID instead of the
logical volume and index ID pair.)
.IP key 5
A vector pointing to the key portion of an index entry. 
.IP el 5
A vector pointing to the element portion of an index entry.

.LP
.B "create_index(lvid, ntype, property, key_desc, size_kb_hint, liid)"
.IP
The
.FN create_index
methods creates a new B+tree index on the volume
.VA lvid,
and returns its serial number in
.VA liid.
The
.VA ntype
parameter specifies the type of implementation used for the index.
Valid values for the
.VA ntype
parameter are
.B t_btree,
indicating a B+tree allowing entries with duplicate keys,
and
.B t_uni_btree,
indicating a B+tree only allowing entries with unique keys.
The 
.VA property
parameter specifies whether the index is temporary.
See
.SA enum(ssm)
for more information on
.B ss_m::store_property_t.
.IP
The
.VA key_desc
parameter is a string describing the the type of the keys to be stored
in the index.  The syntax of
.VA key_desc
is as follows:
.EX
    <key_type_str>      ::= <key_type>* <v_key_type>
    <key_type>          ::= <type> <len>
    <v_key_type>        ::= <type> <var> <len>
    <type>              ::= 'i' | 'u' | 'f' | 'b'
    <var>               ::= '*' | NULL
    <len>               ::= [1-9][0-9]*
.EE
.IP
A <key_type> contains a type ('i' for integer, 'u' for unsigned, 'f'
for float, 'b' for binary), and a length. A <v_key_type>, which is the
last part of <key_type_str>, can contain an optional indicator ('*')
for variable length field.
A <key_type_str> is composed of multiple <key_type>, and a <v_key_type>;
i.e. only the last field can be variable length.
.EX
   For example the key_desc "i4f8b*1000" specifies a
   key that contains:
	1. a 4 byte integer
	2. an 8 byte float (double)
	3. a variable length binary field that could be as long as
	   as a 1000 bytes.
.EE
.IP
The SSM applies a function to the key values, the result
of which is a string of bytes that can be lexicographically
compared, and yield the correct order.  The SSM contains such
functions for keys of the following types:
signed and unsigned integer keys of length 1, 2, or 4,
floating point keys of length 4 or 8.
Byte strings keys are not interpreted; they
are stored as presented to the SSM.
.IP
The
.VA size_kb_hint
parameter allows the caller to give a hint about the final
size of the index (in K-bytes).  This helps the SM determine
where to allocate space for the index.  For now, the hint's main
purpose is to determine whether the index will fit on one
page or on many.  A value of 0 should be used if it is known
the index will be small or if the final size of the index is
unknown.  Otherwise a value larger than
.B ss_m::page_sz/1000 should be used.
Small (one-page) indexes are available only with the logical-ID
API.  This is because it is possible to re-map the logical ID to a new
index when the tree grows to assume a different form.

.LP
.B "create_index(lvid, ntype, property, cc, key_desc, size_kb_hint, liid)"
.IP
This form of
.FN create_index
allows you to associate with the index, a locking protocol other
than
.VA t_cc_kvl.
See
.SA enum(ssm)
for more information on
.B ss_m::concurrency_t.

.LP
.IP
See the "ROOT INDEX METHODS" section of
.SA volume(ssm)
for information on how to keep track of the indexes on a volume.

.LP
.B "destroy_index(lvid, liid)"
.IP
The
.FN destroy_index
methods destroys the index and deallocates all space used by it.
The space is not available for reuse until
the transaction destroying the index commits.

.LP
.B "bulkld_index(lvid, liid, s_lvid, s_lfid, stats)"
.IP
This
.FN bulkld_index
method bulk loads the
.B empty
index, identified by
.VA lvid
and
.VA liid.
The entries to load must be located, in sorted order, in the
file identified by
.VA s_lvid
and 
.VA s_lfid.
The header of each record in the file contains the key
and the body contains the element (value) associated with the key.
Statistics for the newly loaded index are returned in
.VA stats,
specifically in the
.VA btree 
field.
.LP
.B "bulkld_index(lvid, liid, sorted_stream, stats)"
.IP
This
.FN bulkld_index
method is identical to the one above except that rather than
getting entries from a file, the entries come from
.VA sorted_stream.
.B Note:
this method has not been extensively tested and may change in the
future.  See
.SA sort_stream_i(ssm)
for more information.

.LP
.B "print_index(lvid, liid)"
.IP
The
.FN print_index
method is prints the contents of the index.  It is meant to
be a debugging tool.

.LP
.B "create_assoc(lvid, liid, key, el)"
.IP
The 
.FN create_assoc
method adds a new entry associating
.VA key
with the element (value)
.VA el.

.LP
.B "destroy_assoc(lvid, liid, key, el)"
.IP
The
.FN destroy_assoc
method destroys the entry associating
.VA key
with the element (value)
.VA el.

.LP
.B "destroy_all_assoc(lvid, liid, key, num_removed)"
.IP
The
.FN destroy_all_assoc
method destroys all entries with
.VA key
as a key.  The number of entries removed is returned in
.VA num_removed.

.LP
.B "find_assoc(lvid, liid, key, el, elen, found)"
.IP
The
.FN find_assoc
method finds
.VA key
in the index and
and writes the associated element (only the first one found) to the address specified by
.VA el.
At most
.VA elen
bytes will be written.  If the element is not needed, set
.VA elen
to 0.  
.VA Elen
will be set to the length actually written.
If
.VA key
is found, then
.VA found
will be set to 
.B true.
A more comprehensive lookup facility, allowing range searches,
is available from the class 
.VA scan_index_i 
described in 
.SA scan_index_i(ssm)

.SH ERRORS

All of the above methods return a
.FN w_rc_t
error code.  If an error occurs during a methods that is updating
persistent data (the create, destroy, and bulk load methods will
update data) then the index could be in an inconsistent state.
The caller then has the choice of aborting the transaction or rolling
back to the nearest save-point (see
.SA transaction(ssm)
).

.LP
See
.SA errors(ssm)
for more information on error handling.

.SH EXAMPLES
To Do.

.DA
.SH "SEE ALSO"
.SA scan_index_i(ssm),
.SA sort_stream_i(ssm)
.SA intro(ssm),
