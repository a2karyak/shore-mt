.TH ss_m::rtree ssm "Jan 1999" "Release \*(SV" "Shore Storage Manager" "Release 2.0" "Shore Storage Manager Reference Manual"
.so tmac.man.local
.SH NAME
bulkld_md_index, create_md_assoc, create_md_index, destroy_md_assoc, destroy_md_index, find_md_assoc, print_md_index, draw_rtree rtree_stats \- Class ss_m Methods for R*tree (multi-dimensional) Index Operations

.SH SYNOPSIS
.EX
#include <sm_vas.h>  // includes sm.h (where they are declared)

    /* Logical-ID version */
static rc_t                 create_md_index(const lvid_t&	lvid,
		ndx_t				ntype,
		store_property_t			property,
		serial_t&			liid,
		int2				dim=2);

    /* Physical-ID version */
static rc_t                 create_md_index(vid_t		vid,
		ndx_t				ntype,
		store_property_t			property,
		stid_t&				stid,
		int2_t				dim = 2,
		const serial_t&			logical_id=serial_t::null);

    /* Logical-ID version */
static rc_t                 destroy_md_index(const lvid_t&	lvid,
		const serial_t&			liid);
    /* Physical-ID version */
static rc_t                 destroy_md_index(const stid_t& iid);


    /* Logical-ID version */
static rc_t                 bulkld_md_index(const lvid_t&	lvid,
		const serial_t&			liid,
		const lvid_t&			s_lvid,
		const serial_t&			s_liid,
		sm_du_stats_t&			stats,
		int2				hff=65,
		int2				hef=120,
		nbox_t*				universe=NULL);

    /* Physical-ID version */
static rc_t                 bulkld_md_index(const stid_t&	stid,
		const stid_t&			source,
		sm_du_stats_t&			stats,
		int2_t				hff=75,
		int2_t				hef=120,
		nbox_t*				universe=NULL);

    // version of above that takes multiple input files
static rc_t                 bulkld_md_index(const stid_t&	stid,
		int				nsrcs,
		const stid_t*			source,
		sm_du_stats_t&			stats,
		int2_t 				hff=75,
		int2_t				hef=120,
		nbox_t*				universe=NULL);


    /* Logical-ID version */
static rc_t                 bulkld_md_index(const lvid_t&	lvid,
		const serial_t&			liid,
		sort_stream_i&			sorted_stream,
		sm_du_stats_t&			stats,
		int2				hff=65,
		int2				hef=120,
		nbox_t*				universe=NULL);

    /* Physical-ID version */
static rc_t                 bulkld_md_index(const stid_t&	stid,
		sort_stream_i&			sorted_stream,
		sm_du_stats_t&			stats,
		int2_t 				hff=75,
		int2_t				hef=120,
		nbox_t*				universe=NULL);


    /* Logical-ID version */
static rc_t                 create_md_assoc(const lvid_t&	lvid,
		const serial_t&			liid,
		const nbox_t&			key,
		const vec_t&			el);

    /* Physical-ID version */
static rc_t                 create_md_assoc(stid_t		stid,
		const nbox_t&			key,
		const vec_t&			el);


    /* Logical-ID version */
static rc_t                 destroy_md_assoc(const lvid_t&	lvid,
		const serial_t&			liid,
		const nbox_t&			key,
		const vec_t&			el);

    /* Physical-ID version */
static rc_t                 destroy_md_assoc(stid_t	stid,
		const nbox_t&			key,
		const vec_t&			el);


    /* Logical-ID version */
static rc_t                 find_md_assoc(const lvid_t&	lvid,
		const serial_t&			liid,
		const nbox_t&			key,
		void*				el,
		smsize_t&			elen,
		bool&				found);

    /* Physical-ID version */
static rc_t                 find_md_assoc(stid_t		stid,
		const nbox_t&			key,
		void*				el,
		smsize_t&			elen,
		bool&				found);


    /* Logical-ID version */
static rc_t                 print_md_index(const lvid_t&	lvid,
		const serial_t&			liid);

    /* Physical-ID version */
static rc_t                 print_md_index(stid_t stid);


    /* Logical-ID version */
static rc_t                 draw_rtree(const lvid_t&	lvid,
		const serial_t&			liid);
    /* Physical-ID version */
static rc_t                 draw_rtree(const stid_t& stid, ostream &);


    /* Logical-ID version */
static rc_t                 rtree_stats(const lvid_t&	lvid,
		const serial_t&			liid,
		rtree_stats_t&			stat,
		uint2				size = 0,
		uint2*				ovp = NULL,
		bool 				audit = false);

    /* Physical-ID version */
static rc_t                 rtree_stats(const stid_t&	stid,
		rtree_stats_t&			stat,
		uint2_t				size = 0,
		uint2_t*				ovp = NULL,
		bool				audit = false);



.EE
.SH DESCRIPTION

The above class
.FN ss_m
methods all deal with manipulating multi-dimensional (md)
indexes.  So far, the only type of multi-dimension index provided
by the SSM is the R*tree.  See 
.HR "The Shore Storage Manager Programming Interface" "../ssmapi/ssmapi.html"
for more information on R*trees.

.SS Common Parameters
.LP 
There are a number of common parameters for these methods:
.IP lvid 5
Logical volume ID of volume containing an index.
.IP liid 5
Logical index ID, the serial number of an index.
.IP key 5
A n-dimensional box,
.SA nbox_t(common),
that is the key portion of an index entry.
.IP el 5
A vector pointing to the element portion of an index entry.

.LP
.B "create_md_index(lvid, ntype, property, liid, dim)"
.IP
The
.FN create_md_index
method creates a new B+tree index on the volume
.VA lvid,
and returns its serial number in
.VA liid.
The
.VA ntype
parameter specifies the type of implementation used for the index.
The only valid value for the
.VA ntype
parameter is
.B t_rtree,
indicating an R*tree.
The 
.VA property
parameter specifies whether the index is temporary or not.
See
.SA enum(ssm)
for more information on
.B store_property_t.
The
.VA dim
parameter specifies the number of dimensions for the index.
.B Note:
only 2 dimensions are currently supported.

.LP
.B "destroy_md_index(lvid, liid)"
.IP
The
.FN destroy_index
method destroys the index and deallocates all space used by it.
The space is not available for reuse until
the transaction destroying the index commits.

.LP
.B "bulkld_md_index(lvid, liid, s_lvid, s_lfid, stats, hff, hef, universe)"
.IP
This
.FN bulkld_md_index
method bulk loads the
.B empty
index, identified by
.VA lvid
and
.VA liid.
The entries to load are located, in sorted order, in the
file identified by
.VA s_lvid
and 
.VA s_lfid.
The header of each record in the file contains the key (see
.SA nbox_t(common)).
and the body contains the element (value) associated with the key.
This file must have been sorted by 
.SA sort(ssm)
using the
.B t_spatial
key type to get a spatial linear order (Hilbert curve).
Statistics for the newly loaded index are returned in
.VA stats,
specifically in the
.VA rtree field.
.IP
The
.VA hff
parameter is a heuristic fill factor and
.VA hef
is a heuristic expansion
factor.  They are used to determine when an Rtree page should
stop accepting new entries to reduce the degree of overlap during
bulk loading.
Since bulk loading requires some linear order to map
2-d keys to 1-d disk locations, there definitely will be some
loss of spatial
clustering.  Thus, packing entries 100% to a 
rtree page could result in a very large overlap between
leaf pages.  These heuristics parameters are designed to
minimize this problem.  It is recommended that
the default values always be used.
The default values are chosen to be the best on the average
case. But they not guaranteed best for the worst case (skewed data).
.IP
The
VA universe
parameter is a "box" specifying the boundaries of the "space" containing
the loaded keys.  A more compact index can be built if this parameter
is provided, but it is not necessary.

.LP
.B "bulkld_md_index(lvid, liid, sorted_stream, stats, hff, hef, universe)"
.IP
This
.FN bulkld_md_index
method is identical to the one above except that rather than
getting entries from a file, the entries come from
.VA sorted_stream.
.B Note:
this method has not been extensively tested and may change in the
future.  See
.SA sort_stream_i(ssm)
for more information.

.LP
.B "create_md_assoc(lvid, liid, key, el)"
.IP
The 
.FN create_md_assoc
method adds a new entry associating
.VA key
with the element (value)
.VA el.

.LP
.B "destroy_md_assoc(lvid, liid, key, el)"
.IP
The
.FN destroy_md_assoc
method destroys the entry associating
.VA key
with the element (value)
.VA el.

.LP
.B "find_md_assoc(lvid, liid, key, el, elen, found)"
.IP
The
.FN find_assoc
method finds
.VA key
in the index and and writes the associated element
 (only the first one found) to the address specified by
.VA el.
At most
.VA elen
bytes will be written.  If the element is not needed, set
.VA elen
to 0.  If
.VA key
is found, then
.VA found
will be set to 
.B true.
A more comprehensive lookup facility, allowing range searches,
is available from the class .FN scan_rt_i described in .SA
scan_rt_i(ssm)

.LP
.B "print_md_index(lvid, liid)"
.IP
The
.FN print_md_index
method is prints the contents of the index.  It is meant to
be a debugging utility.

.LP
.B "draw_rtree(lvid, liid)"
.IP
The
.FN draw_rtree
method generates a "gremlin" file for
visualizing an R*-tree graphically.
This method is an unsupported debugging utility.

.LP
.B "rtree_stats(lvid, liid, stat, size, ovp, audit)"
.IP
The
.FN rtree_stats
method is an unsupported debugging utility for gathering
more detailed statistics on an R*tree.
The
.VA stats
parameter is filled with the regular Rtree stats gathered
by
.FN ss_m::get_du_statistics().
The
.VA ovp
parameter is an array that will be filled with overlap
percentage for each level of the R*tree.
The
.VA size
parameter is the size of the array.
If the 
.VA audit
parameter is
.B true,
the stats structure is audited.

.SH ERRORS

All of the above methods return a
.FN w_rc_t
error code.  If an error occurs during a method that is updating
persistent data (the create, destroy, and bulk load method will
update data) then the index could be in an inconsistent state.
The caller then has the choice of aborting the transaction or rolling
back to the nearest save-point (see
.SA transaction(ssm)
).

.LP
See
.SA errors(ssm)
for more information on error handling.

.SH EXAMPLES
To Do.

.DA
.SH "SEE ALSO"
.SA scan_rt_i(ssm)
.SA sort_stream_i(ssm)
.SA intro(ssm)


