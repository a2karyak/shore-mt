# <std-header style='tcl' orig-src='shore'>
#
#  $Id: lgrec.3,v 1.23 1999/06/07 19:05:31 kupsch Exp $
#
# SHORE -- Scalable Heterogeneous Object REpository
#
# Copyright (c) 1994-99 Computer Sciences Department, University of
#                       Wisconsin -- Madison
# All Rights Reserved.
#
# Permission to use, copy, modify and distribute this software and its
# documentation is hereby granted, provided that both the copyright
# notice and this permission notice appear in all copies of the
# software, derivative works or modified versions, and any portions
# thereof, and that both notices appear in supporting documentation.
#
# THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY
# OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS
# "AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND
# FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
#
# This software was developed with support by the Advanced Research
# Project Agency, ARPA order number 018 (formerly 8230), monitored by
# the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.
# Further funding for this work was provided by DARPA through
# Rome Research Laboratory Contract No. F30602-97-2-0247.
#
#   -- do not edit anything above this line --   </std-header>

#
#	Test Create, Destroy of Large Records
#
# Fills the volume and then aborts last operation. 
#
# If you look at the pages this allocates, you'll see that
# it demonstrates the fact that the pages aren't allocated from
# the large-object store as we'd like or expect.
#
#  This demonstrates the horrible linear-in-#extents algorithm for finding
# unallocated in extents.
# 
# lgrec.5 is this script w/o the delete and re-create of the object
# at the beginning of the file. 
#

source $script_dir/vol.init

if { $logging == 0 } {
    echo "Logging off: script not run. "
} else {
echo WARNING: this script takes a long time on a large volume
set_config_info

set long_len [expr $lg_rec_page_space * 50]

# set long_body [format %0$long_len\d  1]
set long_body [formatlong 0 [expr {$long_len-10}] %010d 1]

set llong [string length $long_body]
verbose length of long_body  $llong

verbose 
verbose Create & destroy records of length $llong 
verbose until we run out of space.  Presumably
verbose the pages don't get re-used by this transaction.

set last_pg_offset [expr {$llong - 1} ]

sm begin_xct
set fid [sm create_file $volid regular]
sm commit_xct

set errorno 0
set i 0
while {1} {
    set tm [time {
	sm begin_xct
	    sm set_store_property $fid insert_file
	    set caught [
		catch  {
		    set r [
			sm create_rec $fid $i 10 $long_body 
		    ]

		} errorno
	    ]
	    if {$caught} {
		verbose EXPECTED error EOUTOFSPACE during create: $errorno
		    verbose aborting...
		sm abort_xct
		break
	    }
	    set caught [
		catch  {
		    set s [
			sm create_rec $fid $i 10 $long_body 
		    ]

		} errorno
	    ]
	    if {$caught} {
		verbose EXPECTED error EOUTOFSPACE during create: $errorno
		    verbose aborting...
		sm abort_xct
		break
	    }
	    set stats [pxstats false]
	sm commit_xct
    } 1]
    verbose loop $i: $tm
    verbose $stats
    verbose

    sm begin_xct
	verbose pinning $r
	set p [sm pin_create]
	sm pin_pin $p $r 0
	set pid [sm pin_page_containing $p $last_pg_offset]
	sm pin_unpin $p 
	sm pin_destroy $p
	verbose destroying $r, starts at $pid
	sm destroy_rec $r

	verbose pinning $s
	set p [sm pin_create]
	sm pin_pin $p $s 0
	set pid [sm pin_page_containing $p $last_pg_offset]
	sm pin_unpin $p 
	sm pin_destroy $p
	verbose NOT destroying $s, starts at $pid

    sm commit_xct
    incr i
}

verbose SPACE BEFORE DESTROY
dstats $volid

sm begin_xct
sm destroy_file $fid

verbose volume_quota [sm get_volume_quota $volid]
verbose sm_stats [sm gather_stats]
sm commit_xct

verbose SPACE AFTER DESTROY
dstats $volid

unset r long_body long_len caught fid i errorno
}

