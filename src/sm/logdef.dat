# <std-header style='data' orig-src='shore'>
#
#  $Id: logdef.dat,v 1.61 2008/05/28 01:28:01 nhall Exp $
#
# SHORE -- Scalable Heterogeneous Object REpository
#
# Copyright (c) 1994-99 Computer Sciences Department, University of
#                       Wisconsin -- Madison
# All Rights Reserved.
#
# Permission to use, copy, modify and distribute this software and its
# documentation is hereby granted, provided that both the copyright
# notice and this permission notice appear in all copies of the
# software, derivative works or modified versions, and any portions
# thereof, and that both notices appear in supporting documentation.
#
# THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY
# OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS
# "AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND
# FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
#
# This software was developed with support by the Advanced Research
# Project Agency, ARPA order number 018 (formerly 8230), monitored by
# the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.
# Further funding for this work was provided by DARPA through
# Rome Research Laboratory Contract No. F30602-97-2-0247.
#
#   -- do not edit anything above this line --   </std-header>

#########################################################################
#									#
#	WARNING: if you add, delete or change any of the log records,	#
#	or their data members, or their semantics you also need to	#
#	update log_base::version_major and/or log_base::version_minor	#
#	in log_base.cpp.						#
#                                                                       #
#       For every log record type, the perl script generates a class    #
#       class <type>_log {                                              #
#           void fill(const lpid_t*p, uint2_t tag, int len);            #
#       public:                                                         #
#           <type>_log(<arg>);                                          #
#        // and...                                                      #
#        // iff R bit set:                                              #
#        void redo(page_p *page);                                       #
#        // iff U bit set:                                              #
#        void undo(page_p *page);                                       #
#       }                                                               #
#									#
#	The format of the file is as follows:				#
#		type = log record type					#
#		X    = transaction log (generated by transactions)	#
#                      If set, logstub_gen.cpp contains a function      #
#                      rc_t log_<type> (<arg>) to generate the log recs #
#                      according to convention.  If not, the code else- #
#                      where in the SM has to be written by hand to gen #
#                      the log record.                                  #
#		S    = sync (not used at all anymore)		        #
#		R    = redoable	(-->t_redo bit set in log record)	#
#                      Includes redo method in class                    #
#		U    = undoable	(-->t_undo)				#
#                      Includes undo method in class                    #
#		F    = format	NOT USED                                #
#		A    = space-allocation:                                #
#                      If NOT set, generated code decides if logging    #
#                      should be done, based on :                       #
#                      1) smlevel_1::log, smlevel_0::logging_enabled,   #
#                      2) (if page argument present) page.store_flags   #
#                                            == st_tmp                  #
#                      3) xct() attached and xct()->is_log_on()         #
#                                                                       #
#                      If A bit IS SET, checks #2, #3 are left out      #
#                                                                       #
#		L    = logical undo log record -- don't fix the page    #
#                                        for undo.  Irrelevant if not   #
#                      an undoable log record.                          #
#                      --> t_logical                                    # 
#                                                                       #
#                                                                       #
#		arg  = arguments to constructor				#
#                      SPECIAL CASE: first argument is "page":          #
#                      1) store flags checked to turn off logging for   #
#                      st_tmp files.                                    #
#                      2) give_logbuf() call passes page for 2nd arg    #
#                      3) page.set_dirty() if logging is skipped        #
#									#
#########################################################################
# type			XSRUFAL	 arg					#
#########################################################################
comment		        1011001 (const char* msg);
compensate		1000001 (lsn_t  rec_lsn);
skip			0000000 ();
chkpt_begin		0000000 (const lsn_t &lastMountLSN);
chkpt_bf_tab		0000000	(int cnt, const lpid_t* pid,
					const lsn_t* rec_lsn);
chkpt_xct_tab		0000000	(const tid_t& youngest, 
					int cnt, const tid_t* tid, 
					const smlevel_1::xct_state_t* state,
					const lsn_t* last_lsn, 
					const lsn_t* undo_nxt);
chkpt_dev_tab		0000000	(int cnt, const char **dev_name,
					const vid_t* vid);

chkpt_end		0000000 (const lsn_t& master, const lsn_t& min_rec_lsn);
mount_vol		0010010	(const char *dev_name, const vid_t &vid);
dismount_vol		0010010	(const char *dev_name, const vid_t &vid);
#xct_abort		1000000	();
xct_freeing_space	1000000 ();
xct_end			1000000 ();
xct_prepare_st		1010000 (const gtid_t* g, const server_handle_t& h);
xct_prepare_lk		1010000 (int num, lock_mode_t mode, lockid_t* lks);
xct_prepare_alk		1010000 (int num, lockid_t* lks, lock_mode_t* modes);
xct_prepare_stores	1010000 (int num, const stid_t* stids);
xct_prepare_fi	  	1010000 (int numex, int numix, int numsix, int numextent, const lsn_t& first);
#########################################################################
# type			XSRUFAL	 arg					#
#########################################################################
# page allocation log records - testable(physical) for redo
# undoable
alloc_pages_in_ext	1011011	(const page_p& page, extnum_t idx, const Pmap& pmap);
free_pages_in_ext	1011011	(const page_p& page, extnum_t idx, const Pmap& pmap);

# page allocation log records - testable(physical) for redo
# not undoable:
create_ext_list		1010011 (const page_p& page, const stid_t& stid, extnum_t prev, extnum_t next, extnum_t count, const extnum_t* list);
free_ext_list		1010011 (const page_p& page, const stid_t& stid, extnum_t head, extnum_t count);
set_ext_next		1010011 (const page_p& page, extnum_t ext, extnum_t new_next);
# undoable:
store_operation		1011011 (const page_p& page, const store_operation_param& op);

page_init		1010000 (const page_p& page);
page_link		1011000 (const page_p& page, shpid_t new_prev, 
					shpid_t new_next);
page_insert		1011000 (const page_p& page, int idx, int cnt,
					const cvec_t* vec);
page_remove		1011000 (const page_p& page, int idx, int cnt);
page_format		1011000 (const page_p& page, int idx, int cnt, const cvec_t* vec);
page_mark		1011000 (const page_p& page, int idx);
page_reclaim		1011000 (const page_p& page, int idx, 
					const cvec_t& vec);
page_splice		1011000 (const page_p& page, int idx, int start, 
					int len, const cvec_t& vec);
page_shift		1011000 (const page_p& page, int idx2, 
					page_s::slot_length_t off2, page_s::slot_length_t len2,
					int idx1,  page_s::slot_length_t off1);
page_splicez		1011000 (const page_p& page, int idx, int start, 
					int len, int osave, int nsave, const cvec_t& vec);
page_set_byte		1011000	(const page_p& page, int idx, u_char old, u_char bits, int op);
page_set_bit		1011000	(const page_p& page, int idx, int bit);
page_clr_bit		1011000	(const page_p& page, int idx, int bit);
page_image		1010000 (const page_p& page);
btree_purge		1011001	(const page_p& page);
btree_insert		1011001 (const page_p& page, int idx, 
					const cvec_t& key, const cvec_t& el,
					bool unique);
btree_remove		1011001 (const page_p& page, int idx, 
					const cvec_t& key, const cvec_t& el,
					bool unique);
rtree_insert		1011001 (const page_p& page, int idx,
					const nbox_t& key, const cvec_t& el);
rtree_remove		1011001	(const page_p& page, int idx, 
					const nbox_t& key, const cvec_t& el);

