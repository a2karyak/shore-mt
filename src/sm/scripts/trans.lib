
set docheckpoint 0

source $script_dir/vol.init
proc scanit { f } {
    set scan [sm scan_file_create $f t_cc_record]
    set pin [sm scan_file_next $scan 0]
    set i 0
    while {$pin != "NULL"} {
	set rec [sm pin_rid $pin]
	sm pin_unpin $pin
	set pin [sm scan_file_next $scan 0]
	set i [expr {$i+1} ]
    }
    sm scan_file_destroy $scan
    return $i 
}

proc random_restart { a } {
    set j [random 3]
    for { set i 0 } { $i <= $j } { incr i } {
	_restart $a
    }
}

proc rtrans { clean action finish } {
    global f0 docheckpoint nrecs nrecsnow
    echo 
    echo
    echo starting: rtrans $clean $action $finish docheckpoint=$docheckpoint
    sm begin_xct
    set tx [sm xct]
    set tid [sm xct_to_tid $tx]
    echo  $tid
    set nrecs [scanit $f0]

    if { $action == "readonly" } {
	set nrecsnow $nrecs
    }
    if { $action == "readwrite" } {
	set form %09000d
	set rec [sm create_rec $f0 hdr 1000 [format $form 10] ]
	set nrecsnow [expr {$nrecs + 1}]
	assert {expr [scanit $f0] == $nrecsnow}
    }
    echo before switch $finish
    case $finish in {
	{ "commit.restart" } {
	    sm commit_xct
	} 
	{ "abort.restart" } {
	    sm abort_xct
	    set nrecsnow $nrecs
	} 
	{ "extern.abort.restart" } {
	    sm enter2pc $finish
	    sm abort_xct
	    set nrecsnow $nrecs
	} 
	{ "extern.prepare.commit.restart" } {
	    sm enter2pc $finish
	    if {$docheckpoint == 1} { sm checkpoint }
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    if {$vote != 1} {
		sm commit_xct
	    } else {
		set t [sm xct]
		assert {expr $t==0}
		echo committed
	    }
	} 
	{ "extern.prepare.abort.restart" } {
	    sm enter2pc $finish
	    # just to test fuzzy ckpts
	    if {$docheckpoint == 1} { sm checkpoint }
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    if {$vote != 1} {
		sm abort_xct
	    } else {
		set t [sm xct]
		assert {expr $t==0}
		echo aborted/readonly
	    }
	    set nrecsnow $nrecs
	} 
	{ "extern.restart" } {
	   # recover, should not be found
	    sm enter2pc $finish
	    echo restarting...
	    random_restart $clean
	    echo SHOULD GET ERROR: no such prepared tx
		catch {sm recover2pc $finish} catcherr
		echo recover2pc error: $catcherr
	    # aborted so restore nrecsnow
	    set nrecsnow $nrecs
	}
	{ "extern.prepare.restart.commit" } {
	   # recover, find, commit (unless readonly)
	    sm enter2pc $finish
	    if {$docheckpoint == 1} { sm checkpoint }
	    sm dump_locks
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    echo restarting...
	    random_restart $clean
	    if { $action == "readonly" }  {
		echo SHOULD GET ERROR: no such prepared tx
		catch {sm recover2pc $finish} catcherr
		echo recover2pc error: $catcherr
		# Now, if this were in fact
		# distributed, we'd expect this
		# to abort because one was readonly
		# and therefore indistinguishable
		# from an aborted tx
	    } else {
		set t [sm recover2pc $finish]
		assert {expr $t != 0}
		# it should be attached
		assert {expr [string compare [sm xct] $t] != 0}
		sm commit_xct
	    }
	}
	{ "extern.prepare.restart.abort" } {
	   # recover, find, abort
	    sm enter2pc $finish
	    if {$docheckpoint == 1} { sm checkpoint }
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    echo restarting...
	    random_restart $clean
	    if { $action == "readonly" }  {
		echo SHOULD GET ERROR: no such prepared tx
		catch {sm recover2pc $finish} catcherr
		echo recover2pc error: $catcherr
	    } else {
		set t [sm recover2pc $finish]
		assert {expr $t != 0}
		# it should be attached
		assert {expr [string compare [sm xct] $t] != 0}
		sm abort_xct
	    }
	    set nrecsnow $nrecs
	} 
    }
    echo after switch
    echo restarting...
    random_restart $clean

    sm begin_xct
    assert {expr [string compare [scanit $f0] $nrecsnow]==0}
    sm commit_xct
    echo finished with: rtrans $clean $action $finish
}

proc trans { action finish } {
    global f0 docheckpoint nrecsnow
    echo 
    echo
    echo starting: trans $action $finish docheckpoint=$docheckpoint
    sm begin_xct
    set tx [sm xct]
    set tid [sm xct_to_tid $tx]
    echo $tid

    set nrecs [scanit $f0]
    if { $action == "readonly" } {
	set nrecsnow $nrecs
    }
    if { $action == "readwrite" } {
	set form %09000d
	set rec [sm create_rec $f0 hdr 1000 [format $form 10] ]
	set nrecsnow [expr {$nrecs + 1}]
	assert {expr [scanit $f0] == $nrecsnow}
    }
    case $finish in {
	{ "commit" } {
	    sm commit_xct
	} 
	{ "abort" } {
	    sm abort_xct
	    set nrecsnow $nrecs
	} 
	{ "extern.commit" } {
	    sm enter2pc "glarch"
	    echo SHOULD GET ERROR: not prepared
	    catch {sm commit_xct $finish} catcherr
	    echo commit_xct error: $catcherr
	    set nrecsnow $nrecs
	} 
	{ "extern.abort" } {
	    sm enter2pc "glarch"
	    sm abort_xct
	    set nrecsnow $nrecs
	} 
	{ "extern.prepare.commit" } {
	    sm enter2pc "glarch"
	    if {$docheckpoint == 1} { sm checkpoint }
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    if {$vote != 1} {
		sm commit_xct
	    } else {
		set t [sm xct]
		assert {expr $t==0}
	    }
	    echo committed 
	} 
	{ "extern.prepare.abort" } {
	    sm enter2pc "glarch"
	    if {$docheckpoint == 1} { sm checkpoint }
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    if {$vote != 1} {
		sm abort_xct
		echo aborted
	    } else {
		set t [sm xct]
		assert {expr $t==0}
		echo read-only aborted
	    }
	    set nrecsnow $nrecs
	} 
	{ "prepare.commit" } {
	    echo SHOULD GET ERROR: not participating in external 2pc
	    set nrecsnow $nrecs
	    if {$docheckpoint == 1} { sm checkpoint }
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    sm commit_xct
	} 
	{ "prepare.abort" } {
	    echo SHOULD GET ERROR: not participating in external 2pc
	    set nrecsnow $nrecs
	    if {$docheckpoint == 1} { sm checkpoint }
	    set vote [sm prepare_xct]
	    echo vote=$vote
	    sm commit_xct
	}
    }
    sm begin_xct
    assert {expr [string compare [scanit $f0] $nrecsnow]==0}
    sm commit_xct
    echo  finished with  trans $action $finish
}
set actionlist { readonly readwrite }

sm begin_xct
set f0 [sm create_file $volid]]
sm commit_xct

sm begin_xct
scanit $f0
sm commit_xct
