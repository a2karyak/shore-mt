# --------------------------------------------------------------- #
# -- Copyright (c) 1994, 1995 Computer Sciences Department,    -- #
# -- University of Wisconsin-Madison, subject to the terms     -- #
# -- and conditions given in the file COPYRIGHT.  All Rights   -- #
# -- Reserved.                                                 -- #
# --------------------------------------------------------------- #

#
#  Recovery test: deallocate and extent and reallocate to another
#  store (btree) and then crash.
#  Should only need one thread for this, but in order to make it
#  crash, we need an intervening thread to insert something into
#  the btree (so that the btree pages aren't recycled on abort)
#  IN this case, when we reallocate, we want to insert it
#  into a btree, so the extent allocation is compensated
#  (withing the btree op).  Undo had better work.
#  (Before we assigned transaction IDs to the extents, thiw
#  was a problem)
# 
#  alloc.9 reallocates to another file (ok)
#

source $script_dir/vol.init

set form %08090d
set short_forma %03000dA
set short_formb %03000dB
set ashort_form %A03000d
set bshort_form %B03000d
set nrecs 16 


#
# firest simply create the files
#

sm begin_xct
set f0 [sm create_file $volid]
set f1 [sm create_index $volid btree]
echo created files $f0 $f1

# populate file 0
for { set i 1} { $i <= $nrecs} { incr i} {
    set j [sm create_rec $f0 h$i 1000 [format $form $i] ]
    set rid($i) $j
    echo created rec $rid($i)
}
echo created $nrecs recs file $f0
sm commit_xct

proc t1 {nrecs} {
    global rid f1 f2 short_forma short_formb

    sm begin_xct
    # destroy  everything in the file but not the file itself
    for { set i 1} { $i <= $nrecs} { incr i} {
	echo t1 sm destroy_rec $rid($i) ...
	sm destroy_rec $rid($i)
	echo t1 destroyed $rid($i)
    }
    echo t1 sync
    sync

    #create a bunch of recs in file 1, hoping we reallocate
    # the extents
    for { set i 1} { $i <= $nrecs} { incr i} {
	echo t1 sync
	sync
	set j [sm create_assoc $f1 [format $short_formb $i] $i ]
	echo created entry $j
    }
    echo  abort_xct
    sm abort_xct
}
proc t2 {nrecs} {
    global f1  bshort_form ashort_form
    sm begin_xct
    for { set i 1} { $i <= $nrecs} { incr i} {
	echo t2 create_assoc $f1 
	set j [sm create_assoc $f1 [format $ashort_form $i] $i ]
	set j [sm create_assoc $f1 [format $bshort_form $i] $i ]
	echo created entry $j
	echo t2 sync
	sync
    }
    echo t2 sync
    sync
    echo commit_xct
    sm commit_xct
}

#
# spawn the threads
#

set y1 [fork_thread t1 $nrecs]
set y2 [fork_thread t2 $nrecs]
for { set i 1} { $i <= $nrecs} { incr i} {
    sync_thread $y1 $y2
}
sync_thread $y1 $y2
join_thread $y1 $y2

#
# clean up
#
sm begin_xct
echo destroy_file $f0
sm destroy_file $f0
sm destroy_index $f1
sm commit_xct

unset i j form short_forma short_formb nrecs f0 f1
